From e210723d1a174369c34b13b8e69daa10e1787031 Mon Sep 17 00:00:00 2001
From: Radek Dostal <radek.dostal@streamunlimited.com>
Date: Thu, 13 Nov 2014 14:02:14 +0100
Subject: [PATCH] stream800: Fix wrong samples received on read

Based on work done on linux kernel:

    iio: ti_am335x_adc: Fix wrong samples received on 1st read

    Previously we tried to read data form ADC even before ADC sequencer
    finished sampling. This led to wrong samples.
    We now wait on ADC status register idle bit to be set.

    Signed-off-by: Patil, Rachna <rachna@ti.com>
    Signed-off-by: Zubair Lutfullah <zubair.lutfullah@gmail.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

On the stream800 this bug was showing up as incorrectly detected boards.

Signed-off-by: Fionn Cleary <fionn.cleary@streamunlimited.com>
---
 board/streamunlimited/stream800/adc.c | 41 ++++++++++++++++++++++-------------
 1 file changed, 26 insertions(+), 15 deletions(-)

diff --git a/board/streamunlimited/stream800/adc.c b/board/streamunlimited/stream800/adc.c
index 8e6413f..909ff60 100644
--- a/board/streamunlimited/stream800/adc.c
+++ b/board/streamunlimited/stream800/adc.c
@@ -38,8 +38,8 @@
 #define REG_IRQWAKEUP			(0x34)
 #define REG_DMAENABLE_SET		(0x38)
 #define REG_DMAENABLE_CLR		(0x3c)
-#define REG_CTRL				(0x40)
-#define REG_ADCSTAT				(0x44)
+#define REG_CTRL			(0x40)
+#define REG_ADCSTAT			(0x44)
 #define REG_ADCRANGE			(0x48)
 #define REG_ADC_CLKDIV			(0x4c)
 #define REG_ADC_MISC			(0x50)
@@ -48,7 +48,7 @@
 #define REG_TS_CHARGE_STEPCONFIG	(0x5c)
 #define REG_TS_CHARGE_DELAY		(0x60)
 
-#define REG_STEPCONFIG(X)		(0x64	+ ((X) * 8))
+#define REG_STEPCONFIG(X)			(0x64 + ((X) * 8))
 #define REG_STEPCONFIG_FIFO_SEL			(1 << 26)
 #define REG_STEPCONFIG_DIFF_CNTRL		(1 << 25)
 #define REG_STEPCONFIG_SEL_RFM_SWC_1_0(X)	(X << 23)
@@ -68,17 +68,20 @@
 #define REG_STEPCONFIG_AVG_4			(2 << 2)
 #define REG_STEPCONFIG_AVG_8			(3 << 2)
 #define REG_STEPCONFIG_AVG_16			(4 << 2)
-#define REG_STEPCONFIG_MODE_SW_ONESHOT	(0)
+#define REG_STEPCONFIG_MODE_SW_ONESHOT		(0)
 #define REG_STEPCONFIG_MODE_SW_CONT		(1)
-#define REG_STEPCONFIG_MODE_HW_ONESHOT	(2)
+#define REG_STEPCONFIG_MODE_HW_ONESHOT		(2)
 #define REG_STEPCONFIG_MODE_HW_CONT		(3)
 
 #define REG_STEPDELAY(X)		(0x68	+ ((X) * 8))
 #define REG_FIFOCOUNT(X)		(0xe4 	+ ((X) * 0xc))
-#define REG_FIFOTHRESHOLD(X)	(0xe8	+ ((X) * 0xc))
+#define REG_FIFOTHRESHOLD(X)		(0xe8	+ ((X) * 0xc))
 #define REG_DMAREQ(X)			(0xec	+ ((X) * 0xc))
 #define REG_FIFODATA(X)			(0x100	+ ((X) * 0x100))
 
+/* Sequencer Status */
+#define SEQ_STATUS BIT(5)
+
 //static const struct cm_wkuppll *cmwkup = (struct cm_wkuppll *)CM_WKUP;
 
 static unsigned long int adc_readl(unsigned long reg)
@@ -102,39 +105,47 @@ int init_adc(void)
 	return 0;
 }
 
-
 int read_adc_channel(int channel)
 {
+	/*
+	 * Based on comment from the linux driver (ti_am335x_tscadc.h), it
+	 * takes 5µs to process one sample.  The question then is how fast can
+	 * our loop below run; a guesstimate would be that our processor is
+	 * running at a max of 1GHz, and in that case the entire loop body
+	 * would have to run in 5 cycles, for the timout to occur inside of
+	 * 5µs.  The code in that loop takes a lot longer than 5 cycles to run,
+	 * so the timeout of 1000 should be very conservative.  Comment from
+	 * Linux driver: ADC runs at 3MHz, and it takes 15 cycles to latch one
+	 * data output.  Hence the idle time for ADC to process one sample data
+	 * would be around 5 micro seconds.
+	 */
 	unsigned timeout = 1000;
-
 	/* make step config regs writeable */
 	adc_writel(1 << 2, REG_CTRL);
-
 	/* use step #1 only */
 	adc_writel(REG_STEPCONFIG_AVG_16 |
 		   REG_STEPCONFIG_FIFO_SEL |
 		   REG_STEPCONFIG_MODE_SW_ONESHOT |
 		   REG_STEPCONFIG_SEL_INP_SWC_3_0(channel),
 		   REG_STEPCONFIG(0));
-
 	/* enable charge and step1 */
 	adc_writel(1 << 1, REG_STEPENABLE);
-
 	/* set delay time between 16 measurements */
 	adc_writel((32 << 24) + 32 , REG_STEPDELAY(0));
-
 	/* GO! */
 	adc_writel(1 << 0, REG_CTRL);
 
 	while (timeout-- > 0) {
 		int fifo;
 
+		/* Wait for ADC sequencer to complete sampling */
+		if (adc_readl(REG_ADCSTAT) & SEQ_STATUS)
+			continue;
 		for (fifo = 0; fifo < 2; fifo++)
 			if ((adc_readl(REG_FIFOCOUNT(fifo)) > 0))
 				return adc_readl(REG_FIFODATA(fifo)) % 0xfff;
-
-		//printf("waiting ... state %08x\n", adc_readl(REG_ADCSTAT));
+		//printf("waiting ... state %08lx\n", adc_readl(REG_ADCSTAT));
 	}
-
+	printf("Read from ADC channel: %d timed out!\n", channel);
 	return -1UL;
 }
-- 
2.7.4

