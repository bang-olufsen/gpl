From af8119eaf6bccedd3cf557dd7807d59331175787 Mon Sep 17 00:00:00 2001
From: Lee Page <lee.page@streamunlimited.com>
Date: Thu, 20 Nov 2014 12:53:53 +0100
Subject: [PATCH] ASoC: codecs: add pcm dummy driver

This driver accepts the specified formats and rates without any hardware
configuration over I2C. It is assumed the DAC is in bootstrap mode or can
auto detect the sample rates and formats received.

The reset gpio defined in the device tree can be used as a hardware reset
signal.

Signed-off-by: Lee Page <lee.page@streamunlimited.com>
[squashed with Lee's commits extending it to 3072kHz]
[remove #define DEBUG]
[squashed with Martin's commit Add amplifier unmute on probe ...]
[squashed with Martin's commit Add S24_3LE format for DoP playback]
[squashed with Martin's commit Fix coding style issues]
Signed-off-by: Radek Dostal <radek.dostal@streamunlimited.com>
---
 sound/soc/codecs/Kconfig     |   3 +
 sound/soc/codecs/Makefile    |   2 +
 sound/soc/codecs/pcm-dummy.c | 245 +++++++++++++++++++++++++++++++++++++++++++
 sound/soc/davinci/Kconfig    |   1 +
 4 files changed, 251 insertions(+)
 create mode 100644 sound/soc/codecs/pcm-dummy.c

diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index a985a58..1b207e6 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -483,6 +483,9 @@ config SND_SOC_PCM3008
 config SND_SOC_PCM3060
        tristate
 
+config SND_SOC_PCMDUMMY
+	tristate
+
 config SND_SOC_PCM512x
 	tristate
 
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index 01cc1b8..b942a80 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -74,6 +74,7 @@ snd-soc-pcm1681-objs := pcm1681.o
 snd-soc-pcm1792a-codec-objs := pcm1792a.o
 snd-soc-pcm3008-objs := pcm3008.o
 snd-soc-pcm3060-objs := pcm3060.o
+snd-soc-pcm-dummy-objs := pcm-dummy.o
 snd-soc-pcm512x-objs := pcm512x.o
 snd-soc-pcm512x-i2c-objs := pcm512x-i2c.o
 snd-soc-pcm512x-spi-objs := pcm512x-spi.o
@@ -260,6 +261,7 @@ obj-$(CONFIG_SND_SOC_PCM1681)	+= snd-soc-pcm1681.o
 obj-$(CONFIG_SND_SOC_PCM1792A)	+= snd-soc-pcm1792a-codec.o
 obj-$(CONFIG_SND_SOC_PCM3008)	+= snd-soc-pcm3008.o
 obj-$(CONFIG_SND_SOC_PCM3060)	+= snd-soc-pcm3060.o
+obj-$(CONFIG_SND_SOC_PCMDUMMY)	+= snd-soc-pcm-dummy.o
 obj-$(CONFIG_SND_SOC_PCM512x)	+= snd-soc-pcm512x.o
 obj-$(CONFIG_SND_SOC_PCM512x_I2C)	+= snd-soc-pcm512x-i2c.o
 obj-$(CONFIG_SND_SOC_PCM512x_SPI)	+= snd-soc-pcm512x-spi.o
diff --git a/sound/soc/codecs/pcm-dummy.c b/sound/soc/codecs/pcm-dummy.c
new file mode 100644
index 0000000..5b2808e
--- /dev/null
+++ b/sound/soc/codecs/pcm-dummy.c
@@ -0,0 +1,245 @@
+/*
+ * pcm_dummy.c  --  dummy PCM ALSA SoC Audio driver
+ *
+ * Copyright 2014 Streamunlimited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/spi/spi.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/regulator/consumer.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/tlv.h>
+
+#define DRIVER_NAME "pcm-dummy"
+
+struct pcm_dummy_private {
+	struct device  *dev;	/* attached platform device */
+
+	unsigned gpio_nmute;
+	unsigned gpio_nreset;
+};
+
+static int pcm_dummy_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int format)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct pcm_dummy_private *ctx = snd_soc_codec_get_drvdata(codec);
+
+	dev_dbg(ctx->dev, "pcm_dummy_set_dai_fmt() called, format = %d\n", format);
+	return 0;
+}
+
+static int pcm_dummy_digital_mute(struct snd_soc_dai *codec_dai, int mute)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct pcm_dummy_private *ctx = snd_soc_codec_get_drvdata(codec);
+
+	dev_dbg(ctx->dev, "pcm_dummy_digital_mute() called: %s\n", mute ? "muted" : "unmuted");
+	return 0;
+}
+
+static int pcm_dummy_set_dai_sysclk(struct snd_soc_dai *codec_dai, int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct pcm_dummy_private *ctx = snd_soc_codec_get_drvdata(codec);
+
+	dev_dbg(ctx->dev, "pcm_dummy_set_dai_sysclk() called: clk_id = %d, freq = %d, dir = %d\n", clk_id, freq, dir);
+	return 0;
+}
+
+static const struct snd_soc_dai_ops pcm_dummy_dai_ops = {
+	.set_fmt	= pcm_dummy_set_dai_fmt,
+	.set_sysclk	= pcm_dummy_set_dai_sysclk,
+	.digital_mute	= pcm_dummy_digital_mute,
+};
+
+#define PCM_DUMMY_RATES (\
+		SNDRV_PCM_RATE_5512  | SNDRV_PCM_RATE_8000 |\
+		SNDRV_PCM_RATE_11025 | SNDRV_PCM_RATE_16000 |\
+		SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 |\
+		SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 |\
+		SNDRV_PCM_RATE_64000 | SNDRV_PCM_RATE_88200 |\
+		SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_176400 |\
+		SNDRV_PCM_RATE_192000 | SNDRV_PCM_RATE_352800 |\
+		SNDRV_PCM_RATE_384000 | SNDRV_PCM_RATE_705600 |\
+		SNDRV_PCM_RATE_768000 | SNDRV_PCM_RATE_1411200 |\
+		SNDRV_PCM_RATE_1536000 | SNDRV_PCM_RATE_2822400 |\
+		SNDRV_PCM_RATE_3072000)
+
+#define PCM_DUMMY_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_S32_LE | SNDRV_PCM_FMTBIT_DSD_U8)
+
+struct snd_soc_dai_driver pcm_dummy_dai = {
+	.name = "Dummy PCM Codec",
+	.playback = {
+		.stream_name	= "Playback",
+		.channels_min	= 2,
+		.channels_max	= 2,
+		.rates			= PCM_DUMMY_RATES,
+		.formats		= PCM_DUMMY_FORMATS,},
+	.capture = {
+		.stream_name	= "Capture",
+		.channels_min	= 2,
+		.channels_max	= 2,
+		.rates			= PCM_DUMMY_RATES,
+		.formats		= PCM_DUMMY_FORMATS,},
+	.ops = &pcm_dummy_dai_ops,
+	.symmetric_rates = 1,
+};
+
+#ifdef CONFIG_OF
+static const struct of_device_id pcm_dummy_dt_ids[] = {
+	{ .compatible = "sue,pcm_dummy", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, pcm_dummy_dt_ids);
+#endif
+
+static int pcm_dummy_soc_probe(struct snd_soc_codec *codec)
+{
+	struct pcm_dummy_private *ctx = snd_soc_codec_get_drvdata(codec);
+
+	dev_dbg(ctx->dev, "pcm_dummy_soc_probe() called\n");
+	return 0;
+}
+
+static int pcm_dummy_soc_remove(struct snd_soc_codec *codec)
+{
+	struct pcm_dummy_private *ctx = snd_soc_codec_get_drvdata(codec);
+
+	dev_dbg(ctx->dev, "pcm_dummy_soc_remove() called\n");
+	return 0;
+}
+
+int pcm_dummy_soc_suspend(struct snd_soc_codec *codec)
+{
+	struct pcm_dummy_private *ctx = snd_soc_codec_get_drvdata(codec);
+
+	dev_dbg(ctx->dev, "pcm_dummy_soc_suspend() called\n");
+	return 0;
+}
+
+int pcm_dummy_soc_resume(struct snd_soc_codec *codec)
+{
+	struct pcm_dummy_private *ctx = snd_soc_codec_get_drvdata(codec);
+
+	dev_dbg(ctx->dev, "pcm_dummy_soc_resume() called\n");
+	return 0;
+}
+
+static struct snd_soc_codec_driver soc_codec_dev_pcm_dummy = {
+	.probe			= pcm_dummy_soc_probe,
+	.remove			= pcm_dummy_soc_remove,
+	.suspend		= pcm_dummy_soc_suspend,
+	.resume			= pcm_dummy_soc_resume,
+	.reg_cache_default	= NULL,
+	.reg_cache_size		= 0,
+	.reg_word_size		= 0,
+};
+
+static int pcm_dummy_probe(struct platform_device *pDev)
+{
+	struct device *dev = &pDev->dev;
+	struct pcm_dummy_private *pdata = NULL;
+	const struct of_device_id *match = NULL;
+	int ret = 0;
+
+	dev_dbg(dev, "pcm_dummy_probe(): starting\n");
+
+	match = of_match_device(pcm_dummy_dt_ids, dev);
+
+	if (match == NULL) {
+		dev_err(dev, "%s(%d): failed!\n", __func__, __LINE__);
+		return -EINVAL;
+	}
+
+	pdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return -ENOMEM;
+
+	pdata->dev = dev;
+
+	platform_set_drvdata(pDev, pdata);
+
+	#ifdef CONFIG_OF
+	pdata->gpio_nreset = of_get_named_gpio(dev->of_node, "reset-gpio", 0);
+	pdata->gpio_nmute  = of_get_named_gpio(dev->of_node, "mute-gpio", 0);
+	#endif
+
+
+	/* TODO: release GPIOs on module remove */
+	if (gpio_is_valid(pdata->gpio_nreset)) {
+		ret = gpio_request_one(pdata->gpio_nreset, GPIOF_OUT_INIT_HIGH, "Dummy codec reset GPIO");
+
+		if (ret < 0)
+			dev_warn(dev, "failed to request reset gpio: %d\n", ret);
+		else {
+			/* Reset codec */
+			gpio_direction_output(pdata->gpio_nreset, 0);
+			udelay(1000);
+			gpio_set_value(pdata->gpio_nreset, 1);
+
+			/* Give the codec time to wake up */
+			udelay(1000);
+		}
+	}
+
+	/* Enable the amplifier */
+	if (gpio_is_valid(pdata->gpio_nmute)) {
+		ret = gpio_request_one(pdata->gpio_nmute, GPIOF_OUT_INIT_LOW, "Dummy codec amplifier mute GPIO");
+
+		if (ret < 0)
+			dev_warn(dev, "failed to request mute gpio: %d\n", ret);
+		else
+			gpio_set_value(pdata->gpio_nmute, 1);
+	}
+
+	ret = snd_soc_register_codec(dev, &soc_codec_dev_pcm_dummy, &pcm_dummy_dai, 1);
+
+	if (ret < 0) {
+		dev_err(dev, "pcm_dummy_probe(): failed with error %d\n", ret);
+		return ret;
+	}
+
+	dev_dbg(dev, "pcm_dummy_probe(): successfully finished\n");
+	return 0;
+}
+
+static int pcm_dummy_remove(struct platform_device *pDev)
+{
+	struct pcm_dummy_private *pData = platform_get_drvdata(pDev);
+
+	dev_dbg(&pDev->dev, "pcm_dummy_remove(): starting\n");
+
+	kfree(pData);
+	platform_set_drvdata(pDev, NULL);
+
+	dev_dbg(&pDev->dev, "pcm_dummy_remove(): successfully finished\n");
+	return 0;
+}
+
+static struct platform_driver pcm_dummy_platform_driver = {
+	.probe	= pcm_dummy_probe,
+	.remove	= pcm_dummy_remove,
+	.driver	= {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(pcm_dummy_dt_ids),
+	},
+};
+
+module_platform_driver(pcm_dummy_platform_driver);
+
+MODULE_DESCRIPTION("ASoC PCM dummy driver");
+MODULE_AUTHOR("Lee Page");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/davinci/Kconfig b/sound/soc/davinci/Kconfig
index ea49283..82b542c 100644
--- a/sound/soc/davinci/Kconfig
+++ b/sound/soc/davinci/Kconfig
@@ -108,6 +108,7 @@ config  SND_AM335X_SOC_S800
 	select SND_SOC_AK5386
 	select SND_SOC_TAS5086
 	select SND_SOC_PCM3060
+	select SND_SOC_PCMDUMMY
 	select SND_SOC_ADAU1701
 	select SND_SOC_STA350
 	select SND_SOC_SPDIF
-- 
1.9.1

