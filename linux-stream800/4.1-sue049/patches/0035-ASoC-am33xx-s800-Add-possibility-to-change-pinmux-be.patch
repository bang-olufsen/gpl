From 3594150fc205bae989b815ce621f9a84302fa1be Mon Sep 17 00:00:00 2001
From: Martin Pietryka <martin.pietryka@streamunlimited.com>
Date: Thu, 23 Apr 2015 16:41:26 +0200
Subject: [PATCH] ASoC: am33xx-s800: Add possibility to change pinmux between
 dsd and pcm.

See the accompanying changes to the highend devicetree in
Stream800-setup.

Signed-off-by: Martin Pietryka <martin.pietryka@streamunlimited.com>
---
 sound/soc/davinci/am33xx-s800.c | 36 +++++++++++++++++++++++++++++++++---
 1 file changed, 33 insertions(+), 3 deletions(-)

diff --git a/sound/soc/davinci/am33xx-s800.c b/sound/soc/davinci/am33xx-s800.c
index 689e7d8..44c5ba0 100644
--- a/sound/soc/davinci/am33xx-s800.c
+++ b/sound/soc/davinci/am33xx-s800.c
@@ -44,6 +44,9 @@ struct snd_soc_am33xx_s800 {
 	struct snd_kcontrol	*amp_overheat_kctl;
 	struct regulator	*regulator;
 	const char		*serial_config; /* I (I2S only), D (DSD only), M (I2S and DSD), S (SPDIF), - (do not use) */
+
+	struct pinctrl *pinctrl;
+	struct pinctrl_state *pinctrl_state_pcm, *pinctrl_state_dsd;
 };
 
 static int am33xx_s800_setup_mcasp(struct snd_pcm_substream *substream, snd_pcm_format_t format)
@@ -106,6 +109,16 @@ static int am33xx_s800_setup_mcasp(struct snd_pcm_substream *substream, snd_pcm_
 		return -EINVAL;
 	}
 
+	if (is_dsd) {
+		ret = pinctrl_select_state(priv->pinctrl, priv->pinctrl_state_dsd);
+		if (ret < 0)
+			dev_warn(card->dev, "could not select dsd pins\n");
+	} else {
+		ret = pinctrl_select_state(priv->pinctrl, priv->pinctrl_state_pcm);
+		if (ret < 0)
+			dev_warn(card->dev, "could not select pcm pins\n");
+	}
+
 	ret = snd_soc_dai_set_channel_map(cpu_dai, nch, tx_slots, 0, NULL);
 	if (ret < 0) {
 		dev_warn(card->dev, "Failed to reconfigure channel map\n");
@@ -491,7 +504,6 @@ static int snd_soc_am33xx_s800_probe(struct platform_device *pdev)
 	struct device_node *top_node, *node;
 	struct snd_soc_am33xx_s800 *priv;
 	struct snd_soc_dai_link *link;
-	struct pinctrl *pinctrl;
         const struct of_device_id *of_id =
                         of_match_device(snd_soc_am33xx_s800_match, dev);
 
@@ -508,10 +520,28 @@ static int snd_soc_am33xx_s800_probe(struct platform_device *pdev)
 	dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF;
 
 	/* request pin mux */
-	pinctrl = devm_pinctrl_get_select_default(dev);
-	if (IS_ERR(pinctrl))
+	priv->pinctrl = devm_pinctrl_get(dev);
+	if (IS_ERR(priv->pinctrl))
 		dev_warn(dev, "pins are not configured from the driver\n");
 
+	priv->pinctrl_state_pcm = pinctrl_lookup_state(priv->pinctrl, "pcm");
+	if (IS_ERR(priv->pinctrl_state_pcm)) {
+		dev_warn(dev, "pcm pin lookup failed, retrying with default\n");
+
+		priv->pinctrl_state_pcm = pinctrl_lookup_state(priv->pinctrl, PINCTRL_STATE_DEFAULT);
+		if (IS_ERR(priv->pinctrl_state_pcm))
+			dev_warn(dev, "default pins also not found, check your devicetree\n");
+	}
+
+	priv->pinctrl_state_dsd = pinctrl_lookup_state(priv->pinctrl, "dsd");
+	if (IS_ERR(priv->pinctrl_state_dsd))
+		dev_warn(dev, "dsd pin lookup failed\n");
+
+	/* Enable pcm pins as default */
+	ret = pinctrl_select_state(priv->pinctrl, priv->pinctrl_state_pcm);
+	if (ret < 0)
+		dev_warn(dev, "could not select pcm pins\n");
+
 	priv->mclk = of_clk_get(top_node, 0);
 	if (IS_ERR(priv->mclk)) {
 		dev_err(dev, "failed to get MCLK\n");
-- 
1.9.1

