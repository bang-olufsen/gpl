From aea0ea116c17ea87eb0193b8973e622a601aa0a6 Mon Sep 17 00:00:00 2001
From: Martin Pietryka <martin.pietryka@streamunlimited.com>
Date: Tue, 17 Nov 2015 15:41:48 +0100
Subject: [PATCH] ASoC: am33xx-s800: Add option for persistent clocks on boot

This removes the "tx-lrclk-always" option from the mcasp and adds the
option "sue,persistent-clocks" to the sue audio. If this option is
enabled, the davinci driver will start outputting I2S clocks for 48kHz at
boot time. Also the clocks will stils continue to run after audio playback
has stopped.

This is not done in the nicest way possible but not too hackish either,
still would be nice to clean it up a bit in the future.

Signed-off-by: Martin Pietryka <martin.pietryka@streamunlimited.com>
---
 sound/soc/davinci/am33xx-s800.c | 41 +++++++++++++++++++++++++++++++++++++++++
 1 file changed, 41 insertions(+)

diff --git a/sound/soc/davinci/am33xx-s800.c b/sound/soc/davinci/am33xx-s800.c
index 44c5ba0..97daa1b 100644
--- a/sound/soc/davinci/am33xx-s800.c
+++ b/sound/soc/davinci/am33xx-s800.c
@@ -25,6 +25,8 @@
 #include <sound/pcm_params.h>
 #include <sound/soc.h>
 
+#include "davinci-mcasp.h"
+
 #define DATA_WORD_WIDTH 32
 
 #define MCLK_48k	24576000
@@ -47,6 +49,7 @@ struct snd_soc_am33xx_s800 {
 
 	struct pinctrl *pinctrl;
 	struct pinctrl_state *pinctrl_state_pcm, *pinctrl_state_dsd;
+	bool persistent_clocks;
 };
 
 static int am33xx_s800_setup_mcasp(struct snd_pcm_substream *substream, snd_pcm_format_t format)
@@ -496,6 +499,36 @@ static const struct of_device_id snd_soc_am33xx_s800_match[] = {
 	{ }
 };
 
+static int am33xx_s800_link_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_card *card = codec_dai->component->card;
+	struct snd_soc_am33xx_s800 *priv = snd_soc_card_get_drvdata(card);
+
+	if (priv->persistent_clocks) {
+		priv->mclk_rate = MCLK_48k;
+		am33xx_s800_set_mclk(priv, SNDRV_PCM_STREAM_PLAYBACK);
+
+		snd_soc_dai_set_sysclk(cpu_dai, 0, priv->mclk_rate, SND_SOC_CLOCK_IN);
+
+		snd_soc_dai_set_sysclk(codec_dai, 0, priv->mclk_rate, SND_SOC_CLOCK_IN);
+
+		/* MCLK divider */
+		snd_soc_dai_set_clkdiv(cpu_dai, 0, 1);
+
+		/* BCLK divider */
+		snd_soc_dai_set_clkdiv(cpu_dai, 1, priv->mclk_rate / (48000 * 2 * DATA_WORD_WIDTH));
+
+		/* BCLK-to-LRCLK divider */
+		snd_soc_dai_set_clkdiv(cpu_dai, 2, 2 * DATA_WORD_WIDTH);
+
+		mcasp_enable_persistent_clocks(cpu_dai);
+	}
+
+	return 0;
+}
+
 static int snd_soc_am33xx_s800_probe(struct platform_device *pdev)
 {
 	int ret;
@@ -574,6 +607,12 @@ static int snd_soc_am33xx_s800_probe(struct platform_device *pdev)
 	priv->card.dev = dev;
 	snd_soc_of_parse_card_name(&priv->card, "sue,card-name");
 
+	if (of_get_property(top_node, "sue,persistent-clocks", NULL)) {
+		priv->persistent_clocks = true;
+	} else {
+		priv->persistent_clocks = false;
+	}
+
 	node = of_get_child_by_name(top_node, "links");
 	if (node) {
 		struct device_node *child;
@@ -608,6 +647,8 @@ static int snd_soc_am33xx_s800_probe(struct platform_device *pdev)
 			of_property_read_string(child, "sue,codec-dai-name",
 						&link->codec_dai_name);
 
+			link->init = am33xx_s800_link_init;
+
 			if (of_get_property(child, "sue,codec-is-bfclk-master", NULL))
 				dai_fmt_link |= SND_SOC_DAIFMT_CBM_CFM;
 			else
-- 
1.9.1

