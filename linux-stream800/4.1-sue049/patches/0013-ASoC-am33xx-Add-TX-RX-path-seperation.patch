From 5c6d38b4f27504004a3d074329d37e48f9a329c8 Mon Sep 17 00:00:00 2001
From: Martin Pietryka <martin.pietryka@streamunlimited.com>
Date: Tue, 10 Feb 2015 13:58:32 +0100
Subject: [PATCH] ASoC: am33xx: Add TX/RX path seperation

This commit is based on:
 * 70819d0 ASoC: am33xx-s800: Split TX and RX configuration path

Signed-off-by: Martin Pietryka <martin.pietryka@streamunlimited.com>
---
 sound/soc/davinci/am33xx-s800.c | 108 ++++++++++++++++++++++++++++++++--------
 1 file changed, 88 insertions(+), 20 deletions(-)

diff --git a/sound/soc/davinci/am33xx-s800.c b/sound/soc/davinci/am33xx-s800.c
index 780d6d348..74727f5 100644
--- a/sound/soc/davinci/am33xx-s800.c
+++ b/sound/soc/davinci/am33xx-s800.c
@@ -27,10 +27,15 @@
 
 #define DATA_WORD_WIDTH 32
 
+#define MCLK_48k	24576000
+#define MCLK_44k1	22579200
+
 struct snd_soc_am33xx_s800 {
 	struct snd_soc_card	card;
 	struct clk 		*mclk;
+	struct clk		*mclk_rx;
 	unsigned int		mclk_rate;
+	unsigned int		mclk_rate_rx;
 	signed int		drift;
 	int			passive_mode_gpio;
 	int			amp_overheat_gpio;
@@ -41,19 +46,34 @@ struct snd_soc_am33xx_s800 {
 	struct regulator	*regulator;
 };
 
-static int am33xx_s800_set_mclk(struct snd_soc_am33xx_s800 *priv)
+static int am33xx_s800_set_mclk(struct snd_soc_am33xx_s800 *priv, int stream)
 {
+	struct clk *mclk;
+	long comp, sgn;
+	unsigned long mclk_rate, clk, drift;
 	int ret;
-	unsigned int drift;
-	int sgn = priv->drift > 0 ? 1:-1;
-	signed long comp, clk;
 
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		mclk = priv->mclk;
+		mclk_rate = priv->mclk_rate;
+
+	} else {
+		mclk = priv->mclk_rx;
+		mclk_rate = priv->mclk_rate_rx;
+	}
+
+	sgn = priv->drift > 0 ? 1 : -1;
 	drift = priv->drift * sgn;
-	comp = ((priv->mclk_rate / DATA_WORD_WIDTH) * drift ) / (1000000ULL / DATA_WORD_WIDTH) ;
+
+	comp = ((mclk_rate / DATA_WORD_WIDTH) * drift ) / (1000000ULL / DATA_WORD_WIDTH);
 	comp *= sgn;
-	clk = priv->mclk_rate - comp;
+	clk = mclk_rate - comp;
+
+	ret = clk_set_rate(mclk, clk);
+	if (ret < 0)
+		return ret;
 
-	ret = clk_set_rate(priv->mclk, clk);
+	ret = clk_prepare_enable(mclk);
 	if (ret < 0)
 		return ret;
 
@@ -142,37 +162,64 @@ static int am33xx_s800_common_hw_params(struct snd_pcm_substream *substream,
 	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
 	struct snd_soc_card *card = codec_dai->component->card;
 	struct snd_soc_am33xx_s800 *priv = snd_soc_card_get_drvdata(card);
-	unsigned int clk, rate = params_rate(params);
+	unsigned int mclk, rate;
 	unsigned int bclk_div = is_spdif ? 4 : 2;
 	int ret;
+	int clk_id, div_mclk, div_bclk, div_lrclk;
+
+	rate = params_rate(params);
+	mclk = (rate % 16000 == 0) ? MCLK_48k : MCLK_44k1;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		priv->mclk_rate = mclk;
+
+		clk_id = 0;
+		div_mclk = 0;
+		div_bclk = 1;
+		div_lrclk = 2;
 
-	clk = priv->mclk_rate = (rate % 16000 == 0) ? 24576000 : 22579200;
+	} else {
+		priv->mclk_rate_rx = mclk;
 
-	ret = am33xx_s800_set_mclk(priv);
+		clk_id = 1;
+		div_mclk = 10;
+		div_bclk = 11;
+		div_lrclk = 12;
+	}
+
+	/* if the codec is MCLK master then do not configure our MCLK source */
+	if ((rtd->dai_link->dai_fmt & SND_SOC_DAIFMT_CMM) == 0) {
+		ret = am33xx_s800_set_mclk(priv, substream->stream);
+		if (ret < 0)
+			return ret;
+	}
+
+	ret = am33xx_s800_set_mclk(priv, substream->stream);
 	if (ret < 0)
 		return ret;
 
 	/* propagate the clock rate */
-	ret = snd_soc_dai_set_sysclk(cpu_dai, 0, clk, SND_SOC_CLOCK_IN);
+	ret = snd_soc_dai_set_sysclk(cpu_dai, clk_id, mclk, SND_SOC_CLOCK_IN);
 	if (ret < 0)
 		return ret;
 
 	/* intentionally ignore errors - the codec driver may not care */
-	snd_soc_dai_set_sysclk(codec_dai, 0, clk, SND_SOC_CLOCK_IN);
+	snd_soc_dai_set_sysclk(codec_dai, 0, mclk, SND_SOC_CLOCK_IN);
 
 	/* MCLK divider */
-	ret = snd_soc_dai_set_clkdiv(cpu_dai, 0, 1);
+	ret = snd_soc_dai_set_clkdiv(cpu_dai, div_mclk, 1);
 	if (ret < 0)
 		return ret;
 
+
 	/* BCLK divider */
-	ret = snd_soc_dai_set_clkdiv(cpu_dai, 1,
-			clk / (rate * bclk_div * DATA_WORD_WIDTH));
+	ret = snd_soc_dai_set_clkdiv(cpu_dai, div_bclk, mclk / (rate * bclk_div * DATA_WORD_WIDTH));
 	if (ret < 0)
 		return ret;
 
+
 	/* BCLK-to-LRCLK divider */
-	ret = snd_soc_dai_set_clkdiv(cpu_dai, 2, 2 * DATA_WORD_WIDTH);
+	ret = snd_soc_dai_set_clkdiv(cpu_dai, div_lrclk, 2 * DATA_WORD_WIDTH);
 	if (ret < 0)
 		return ret;
 
@@ -192,7 +239,11 @@ static int am33xx_s800_common_hw_free(struct snd_pcm_substream *substream)
 	struct snd_soc_card *card = codec_dai->component->card;
 	struct snd_soc_am33xx_s800 *priv = snd_soc_card_get_drvdata(card);
 
-	priv->mclk_rate = 0;
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		priv->mclk_rate = 0;
+	} else {
+		priv->mclk_rate_rx = 0;
+	}
 
 	return 0;
 }
@@ -248,7 +299,7 @@ static int am33xx_s800_drift_put(struct snd_kcontrol *kcontrol,
         priv->drift = ucontrol->value.integer.value[0];
 
 	if (priv->mclk_rate) {
-		ret = am33xx_s800_set_mclk(priv);
+		ret = am33xx_s800_set_mclk(priv, SNDRV_PCM_STREAM_PLAYBACK);
 		if (ret < 0)
 			dev_warn(card->dev,
 				 "Unable to set clock rate: %d\n", ret);
@@ -357,7 +408,7 @@ static int snd_soc_am33xx_s800_probe(struct platform_device *pdev)
 	if (!priv)
 		return -ENOMEM;
 
-	dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_CBS_CFS;
+	dai_fmt = SND_SOC_DAIFMT_I2S;
 
 	if (of_get_property(top_node, "sue,invert-wclk", NULL))
 		dai_fmt |= SND_SOC_DAIFMT_NB_IF;
@@ -375,6 +426,12 @@ static int snd_soc_am33xx_s800_probe(struct platform_device *pdev)
 		return -EPROBE_DEFER;
 	}
 
+	priv->mclk_rx = of_clk_get(top_node, 1);
+	if (IS_ERR(priv->mclk_rx)) {
+		dev_err(dev, "failed to get MCLK RX\n");
+		return -EPROBE_DEFER;
+	}
+
 	priv->regulator = devm_regulator_get(dev, "vd");
 	if (IS_ERR(priv->regulator)) {
 		dev_err(dev, "failed to get regulator\n");
@@ -413,6 +470,8 @@ static int snd_soc_am33xx_s800_probe(struct platform_device *pdev)
 		link = priv->card.dai_link;
 
 		for_each_child_of_node(node, child) {
+			unsigned int dai_fmt_link = 0;
+
 			link->platform_of_node = of_parse_phandle(child, "sue,platform", 0);
 			link->codec_of_node = of_parse_phandle(child, "sue,codec", 0);
 
@@ -425,12 +484,21 @@ static int snd_soc_am33xx_s800_probe(struct platform_device *pdev)
 			of_property_read_string(child, "sue,codec-dai-name",
 						&link->codec_dai_name);
 
+			if (of_get_property(child, "sue,codec-is-bfclk-master", NULL))
+				dai_fmt_link |= SND_SOC_DAIFMT_CBM_CFM;
+			else
+				dai_fmt_link |= SND_SOC_DAIFMT_CBS_CFS;
+
+			if (of_get_property(child, "sue,codec-is-mclk-master", NULL))
+				dai_fmt_link |= SND_SOC_DAIFMT_CMM;
+
+
 			if (of_get_property(child, "sue,spdif", NULL))
 				link->ops = &am33xx_s800_spdif_dai_link_ops;
 			else
 				link->ops = &am33xx_s800_i2s_dai_link_ops;
 
-			link->dai_fmt = dai_fmt;
+			link->dai_fmt = dai_fmt | dai_fmt_link;
 			link++;
 		}
 	}
-- 
1.9.1

