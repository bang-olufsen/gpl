/* valadatatype.c generated by valac, the Vala compiler
 * generated from valadatatype.vala, do not modify */

/* valadatatype.vala
 *
 * Copyright (C) 2006-2010  Jürg Billeter
 * Copyright (C) 2006-2008  Raffaele Sandrini
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.

 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * Author:
 * 	Jürg Billeter <j@bitron.ch>
 *	Raffaele Sandrini <raffaele@sandrini.ch>
 */


#include <glib.h>
#include <glib-object.h>
#include "vala.h"
#include <valagee.h>
#include <stdlib.h>
#include <string.h>

#define _vala_iterable_unref0(var) ((var == NULL) ? NULL : (var = (vala_iterable_unref (var), NULL)))
#define _vala_code_node_unref0(var) ((var == NULL) ? NULL : (var = (vala_code_node_unref (var), NULL)))
#define _vala_scope_unref0(var) ((var == NULL) ? NULL : (var = (vala_scope_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _vala_code_context_unref0(var) ((var == NULL) ? NULL : (var = (vala_code_context_unref (var), NULL)))
#define _vala_iterator_unref0(var) ((var == NULL) ? NULL : (var = (vala_iterator_unref (var), NULL)))

struct _ValaDataTypePrivate {
	gboolean _value_owned;
	gboolean _nullable;
	ValaTypeSymbol* _data_type;
	gboolean _floating_reference;
	gboolean _is_dynamic;
	ValaList* type_argument_list;
};


static gint ValaDataType_private_offset;
static gpointer vala_data_type_parent_class = NULL;
static ValaList* vala_data_type__empty_type_list;
static ValaList* vala_data_type__empty_type_list = NULL;

static void vala_data_type_real_accept (ValaCodeNode* base,
                                 ValaCodeVisitor* visitor);
static void vala_data_type_real_accept_children (ValaCodeNode* base,
                                          ValaCodeVisitor* visitor);
static gchar* vala_data_type_real_to_string (ValaCodeNode* base);
static gchar* vala_data_type_real_to_qualified_string (ValaDataType* self,
                                                ValaScope* scope);
static ValaDataType* vala_data_type_real_copy (ValaDataType* self);
static gboolean vala_data_type_real_equals (ValaDataType* self,
                                     ValaDataType* type2);
static gboolean vala_data_type_real_stricter (ValaDataType* self,
                                       ValaDataType* type2);
static void vala_data_type_real_replace_type (ValaCodeNode* base,
                                       ValaDataType* old_type,
                                       ValaDataType* new_type);
static gboolean vala_data_type_real_compatible (ValaDataType* self,
                                         ValaDataType* target_type);
G_GNUC_INTERNAL ValaDataType* vala_semantic_analyzer_get_instance_base_type_for_member (ValaDataType* derived_instance_type,
                                                                        ValaTypeSymbol* type_symbol,
                                                                        ValaCodeNode* node_reference);
static gboolean vala_data_type_real_is_invokable (ValaDataType* self);
static ValaDataType* vala_data_type_real_get_return_type (ValaDataType* self);
static ValaList* vala_data_type_real_get_parameters (ValaDataType* self);
static gboolean vala_data_type_real_is_reference_type_or_type_parameter (ValaDataType* self);
static gboolean vala_data_type_real_is_array (ValaDataType* self);
static gboolean vala_data_type_real_is_accessible (ValaDataType* self,
                                            ValaSymbol* sym);
static ValaSymbol* vala_data_type_real_get_member (ValaDataType* self,
                                            const gchar* member_name);
static ValaSymbol* vala_data_type_real_get_pointer_member (ValaDataType* self,
                                                    const gchar* member_name);
static gboolean vala_data_type_real_is_real_struct_type (ValaDataType* self);
static gboolean vala_data_type_real_is_disposable (ValaDataType* self);
static ValaDataType* vala_data_type_real_get_actual_type (ValaDataType* self,
                                                   ValaDataType* derived_instance_type,
                                                   ValaList* method_type_arguments,
                                                   ValaCodeNode* node_reference);
static ValaDataType* vala_data_type_real_infer_type_argument (ValaDataType* self,
                                                       ValaTypeParameter* type_param,
                                                       ValaDataType* value_type);
static gchar* vala_data_type_real_to_prototype_string (ValaDataType* self,
                                                const gchar* override_name);
static void vala_data_type_finalize (ValaCodeNode * obj);


static inline gpointer
vala_data_type_get_instance_private (ValaDataType* self)
{
	return G_STRUCT_MEMBER_P (self, ValaDataType_private_offset);
}


/**
 * Appends the specified type as generic type argument.
 *
 * @param arg a type reference
 */
void
vala_data_type_add_type_argument (ValaDataType* self,
                                  ValaDataType* arg)
{
	ValaList* _tmp0_;
	ValaList* _tmp3_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (arg != NULL);
	_tmp0_ = self->priv->type_argument_list;
	if (_tmp0_ == NULL) {
		GEqualFunc _tmp1_;
		ValaArrayList* _tmp2_;
		_tmp1_ = g_direct_equal;
		_tmp2_ = vala_array_list_new (VALA_TYPE_DATA_TYPE, (GBoxedCopyFunc) vala_code_node_ref, (GDestroyNotify) vala_code_node_unref, _tmp1_);
		_vala_iterable_unref0 (self->priv->type_argument_list);
		self->priv->type_argument_list = (ValaList*) _tmp2_;
	}
	_tmp3_ = self->priv->type_argument_list;
	vala_collection_add ((ValaCollection*) _tmp3_, arg);
	vala_code_node_set_parent_node ((ValaCodeNode*) arg, (ValaCodeNode*) self);
}


/**
 * Returns a copy of the list of generic type arguments.
 *
 * @return type argument list
 */
static gpointer
_vala_iterable_ref0 (gpointer self)
{
	return self ? vala_iterable_ref (self) : NULL;
}


ValaList*
vala_data_type_get_type_arguments (ValaDataType* self)
{
	ValaList* result = NULL;
	ValaList* _tmp0_;
	ValaList* _tmp3_;
	ValaList* _tmp6_;
	ValaList* _tmp7_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->type_argument_list;
	if (_tmp0_ != NULL) {
		ValaList* _tmp1_;
		ValaList* _tmp2_;
		_tmp1_ = self->priv->type_argument_list;
		_tmp2_ = _vala_iterable_ref0 (_tmp1_);
		result = _tmp2_;
		return result;
	}
	_tmp3_ = vala_data_type__empty_type_list;
	if (_tmp3_ == NULL) {
		GEqualFunc _tmp4_;
		ValaArrayList* _tmp5_;
		_tmp4_ = g_direct_equal;
		_tmp5_ = vala_array_list_new (VALA_TYPE_DATA_TYPE, (GBoxedCopyFunc) vala_code_node_ref, (GDestroyNotify) vala_code_node_unref, _tmp4_);
		_vala_iterable_unref0 (vala_data_type__empty_type_list);
		vala_data_type__empty_type_list = (ValaList*) _tmp5_;
	}
	_tmp6_ = vala_data_type__empty_type_list;
	_tmp7_ = _vala_iterable_ref0 (_tmp6_);
	result = _tmp7_;
	return result;
}


gboolean
vala_data_type_has_type_arguments (ValaDataType* self)
{
	gboolean result = FALSE;
	ValaList* _tmp0_;
	ValaList* _tmp1_;
	gint _tmp2_;
	gint _tmp3_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->type_argument_list;
	if (_tmp0_ == NULL) {
		result = FALSE;
		return result;
	}
	_tmp1_ = self->priv->type_argument_list;
	_tmp2_ = vala_collection_get_size ((ValaCollection*) _tmp1_);
	_tmp3_ = _tmp2_;
	result = _tmp3_ > 0;
	return result;
}


/**
 * Removes all generic type arguments.
 */
void
vala_data_type_remove_all_type_arguments (ValaDataType* self)
{
	g_return_if_fail (self != NULL);
	_vala_iterable_unref0 (self->priv->type_argument_list);
	self->priv->type_argument_list = NULL;
}


static void
vala_data_type_real_accept (ValaCodeNode* base,
                            ValaCodeVisitor* visitor)
{
	ValaDataType * self;
	self = (ValaDataType*) base;
	g_return_if_fail (visitor != NULL);
	vala_code_visitor_visit_data_type (visitor, self);
}


static void
vala_data_type_real_accept_children (ValaCodeNode* base,
                                     ValaCodeVisitor* visitor)
{
	ValaDataType * self;
	gboolean _tmp0_ = FALSE;
	ValaList* _tmp1_;
	self = (ValaDataType*) base;
	g_return_if_fail (visitor != NULL);
	_tmp1_ = self->priv->type_argument_list;
	if (_tmp1_ != NULL) {
		ValaList* _tmp2_;
		gint _tmp3_;
		gint _tmp4_;
		_tmp2_ = self->priv->type_argument_list;
		_tmp3_ = vala_collection_get_size ((ValaCollection*) _tmp2_);
		_tmp4_ = _tmp3_;
		_tmp0_ = _tmp4_ > 0;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		{
			ValaList* _type_arg_list = NULL;
			ValaList* _tmp5_;
			ValaList* _tmp6_;
			gint _type_arg_size = 0;
			ValaList* _tmp7_;
			gint _tmp8_;
			gint _tmp9_;
			gint _type_arg_index = 0;
			_tmp5_ = self->priv->type_argument_list;
			_tmp6_ = _vala_iterable_ref0 (_tmp5_);
			_type_arg_list = _tmp6_;
			_tmp7_ = _type_arg_list;
			_tmp8_ = vala_collection_get_size ((ValaCollection*) _tmp7_);
			_tmp9_ = _tmp8_;
			_type_arg_size = _tmp9_;
			_type_arg_index = -1;
			while (TRUE) {
				gint _tmp10_;
				gint _tmp11_;
				gint _tmp12_;
				ValaDataType* type_arg = NULL;
				ValaList* _tmp13_;
				gint _tmp14_;
				gpointer _tmp15_;
				ValaDataType* _tmp16_;
				_tmp10_ = _type_arg_index;
				_type_arg_index = _tmp10_ + 1;
				_tmp11_ = _type_arg_index;
				_tmp12_ = _type_arg_size;
				if (!(_tmp11_ < _tmp12_)) {
					break;
				}
				_tmp13_ = _type_arg_list;
				_tmp14_ = _type_arg_index;
				_tmp15_ = vala_list_get (_tmp13_, _tmp14_);
				type_arg = (ValaDataType*) _tmp15_;
				_tmp16_ = type_arg;
				vala_code_node_accept ((ValaCodeNode*) _tmp16_, visitor);
				_vala_code_node_unref0 (type_arg);
			}
			_vala_iterable_unref0 (_type_arg_list);
		}
	}
}


static gchar*
vala_data_type_real_to_string (ValaCodeNode* base)
{
	ValaDataType * self;
	gchar* result = NULL;
	gchar* _tmp0_;
	self = (ValaDataType*) base;
	_tmp0_ = vala_data_type_to_qualified_string (self, NULL);
	result = _tmp0_;
	return result;
}


static gpointer
_vala_code_node_ref0 (gpointer self)
{
	return self ? vala_code_node_ref (self) : NULL;
}


static gpointer
_vala_scope_ref0 (gpointer self)
{
	return self ? vala_scope_ref (self) : NULL;
}


static gchar*
vala_data_type_real_to_qualified_string (ValaDataType* self,
                                         ValaScope* scope)
{
	gchar* result = NULL;
	gchar* s = NULL;
	ValaTypeSymbol* _tmp0_;
	ValaList* type_args = NULL;
	ValaList* _tmp36_;
	ValaList* _tmp37_;
	gint _tmp38_;
	gint _tmp39_;
	gboolean _tmp67_;
	_tmp0_ = self->priv->_data_type;
	if (_tmp0_ != NULL) {
		ValaSymbol* global_symbol = NULL;
		ValaTypeSymbol* _tmp1_;
		ValaSymbol* _tmp2_;
		ValaSymbol* sym = NULL;
		ValaScope* parent_scope = NULL;
		ValaScope* _tmp12_;
		gboolean _tmp25_ = FALSE;
		ValaSymbol* _tmp26_;
		_tmp1_ = self->priv->_data_type;
		_tmp2_ = _vala_code_node_ref0 ((ValaSymbol*) _tmp1_);
		global_symbol = _tmp2_;
		while (TRUE) {
			ValaSymbol* _tmp3_;
			ValaSymbol* _tmp4_;
			ValaSymbol* _tmp5_;
			const gchar* _tmp6_;
			const gchar* _tmp7_;
			ValaSymbol* _tmp8_;
			ValaSymbol* _tmp9_;
			ValaSymbol* _tmp10_;
			ValaSymbol* _tmp11_;
			_tmp3_ = global_symbol;
			_tmp4_ = vala_symbol_get_parent_symbol (_tmp3_);
			_tmp5_ = _tmp4_;
			_tmp6_ = vala_symbol_get_name (_tmp5_);
			_tmp7_ = _tmp6_;
			if (!(_tmp7_ != NULL)) {
				break;
			}
			_tmp8_ = global_symbol;
			_tmp9_ = vala_symbol_get_parent_symbol (_tmp8_);
			_tmp10_ = _tmp9_;
			_tmp11_ = _vala_code_node_ref0 (_tmp10_);
			_vala_code_node_unref0 (global_symbol);
			global_symbol = _tmp11_;
		}
		sym = NULL;
		_tmp12_ = _vala_scope_ref0 (scope);
		parent_scope = _tmp12_;
		while (TRUE) {
			gboolean _tmp13_ = FALSE;
			ValaSymbol* _tmp14_;
			ValaScope* _tmp16_;
			ValaSymbol* _tmp17_;
			const gchar* _tmp18_;
			const gchar* _tmp19_;
			ValaSymbol* _tmp20_;
			ValaScope* _tmp21_;
			ValaScope* _tmp22_;
			ValaScope* _tmp23_;
			ValaScope* _tmp24_;
			_tmp14_ = sym;
			if (_tmp14_ == NULL) {
				ValaScope* _tmp15_;
				_tmp15_ = parent_scope;
				_tmp13_ = _tmp15_ != NULL;
			} else {
				_tmp13_ = FALSE;
			}
			if (!_tmp13_) {
				break;
			}
			_tmp16_ = parent_scope;
			_tmp17_ = global_symbol;
			_tmp18_ = vala_symbol_get_name (_tmp17_);
			_tmp19_ = _tmp18_;
			_tmp20_ = vala_scope_lookup (_tmp16_, _tmp19_);
			_vala_code_node_unref0 (sym);
			sym = _tmp20_;
			_tmp21_ = parent_scope;
			_tmp22_ = vala_scope_get_parent_scope (_tmp21_);
			_tmp23_ = _tmp22_;
			_tmp24_ = _vala_scope_ref0 (_tmp23_);
			_vala_scope_unref0 (parent_scope);
			parent_scope = _tmp24_;
		}
		_tmp26_ = sym;
		if (_tmp26_ != NULL) {
			ValaSymbol* _tmp27_;
			ValaSymbol* _tmp28_;
			_tmp27_ = global_symbol;
			_tmp28_ = sym;
			_tmp25_ = _tmp27_ != _tmp28_;
		} else {
			_tmp25_ = FALSE;
		}
		if (_tmp25_) {
			ValaTypeSymbol* _tmp29_;
			gchar* _tmp30_;
			gchar* _tmp31_;
			gchar* _tmp32_;
			_tmp29_ = self->priv->_data_type;
			_tmp30_ = vala_symbol_get_full_name ((ValaSymbol*) _tmp29_);
			_tmp31_ = _tmp30_;
			_tmp32_ = g_strconcat ("global::", _tmp31_, NULL);
			_g_free0 (s);
			s = _tmp32_;
			_g_free0 (_tmp31_);
		} else {
			ValaTypeSymbol* _tmp33_;
			gchar* _tmp34_;
			_tmp33_ = self->priv->_data_type;
			_tmp34_ = vala_symbol_get_full_name ((ValaSymbol*) _tmp33_);
			_g_free0 (s);
			s = _tmp34_;
		}
		_vala_scope_unref0 (parent_scope);
		_vala_code_node_unref0 (sym);
		_vala_code_node_unref0 (global_symbol);
	} else {
		gchar* _tmp35_;
		_tmp35_ = g_strdup ("null");
		_g_free0 (s);
		s = _tmp35_;
	}
	_tmp36_ = vala_data_type_get_type_arguments (self);
	type_args = _tmp36_;
	_tmp37_ = type_args;
	_tmp38_ = vala_collection_get_size ((ValaCollection*) _tmp37_);
	_tmp39_ = _tmp38_;
	if (_tmp39_ > 0) {
		const gchar* _tmp40_;
		gchar* _tmp41_;
		gboolean first = FALSE;
		const gchar* _tmp65_;
		gchar* _tmp66_;
		_tmp40_ = s;
		_tmp41_ = g_strconcat (_tmp40_, "<", NULL);
		_g_free0 (s);
		s = _tmp41_;
		first = TRUE;
		{
			ValaList* _type_arg_list = NULL;
			ValaList* _tmp42_;
			ValaList* _tmp43_;
			gint _type_arg_size = 0;
			ValaList* _tmp44_;
			gint _tmp45_;
			gint _tmp46_;
			gint _type_arg_index = 0;
			_tmp42_ = type_args;
			_tmp43_ = _vala_iterable_ref0 (_tmp42_);
			_type_arg_list = _tmp43_;
			_tmp44_ = _type_arg_list;
			_tmp45_ = vala_collection_get_size ((ValaCollection*) _tmp44_);
			_tmp46_ = _tmp45_;
			_type_arg_size = _tmp46_;
			_type_arg_index = -1;
			while (TRUE) {
				gint _tmp47_;
				gint _tmp48_;
				gint _tmp49_;
				ValaDataType* type_arg = NULL;
				ValaList* _tmp50_;
				gint _tmp51_;
				gpointer _tmp52_;
				gboolean _tmp53_;
				ValaDataType* _tmp56_;
				gboolean _tmp57_;
				const gchar* _tmp60_;
				ValaDataType* _tmp61_;
				gchar* _tmp62_;
				gchar* _tmp63_;
				gchar* _tmp64_;
				_tmp47_ = _type_arg_index;
				_type_arg_index = _tmp47_ + 1;
				_tmp48_ = _type_arg_index;
				_tmp49_ = _type_arg_size;
				if (!(_tmp48_ < _tmp49_)) {
					break;
				}
				_tmp50_ = _type_arg_list;
				_tmp51_ = _type_arg_index;
				_tmp52_ = vala_list_get (_tmp50_, _tmp51_);
				type_arg = (ValaDataType*) _tmp52_;
				_tmp53_ = first;
				if (!_tmp53_) {
					const gchar* _tmp54_;
					gchar* _tmp55_;
					_tmp54_ = s;
					_tmp55_ = g_strconcat (_tmp54_, ",", NULL);
					_g_free0 (s);
					s = _tmp55_;
				} else {
					first = FALSE;
				}
				_tmp56_ = type_arg;
				_tmp57_ = _tmp56_->priv->_value_owned;
				if (!_tmp57_) {
					const gchar* _tmp58_;
					gchar* _tmp59_;
					_tmp58_ = s;
					_tmp59_ = g_strconcat (_tmp58_, "weak ", NULL);
					_g_free0 (s);
					s = _tmp59_;
				}
				_tmp60_ = s;
				_tmp61_ = type_arg;
				_tmp62_ = vala_data_type_to_qualified_string (_tmp61_, scope);
				_tmp63_ = _tmp62_;
				_tmp64_ = g_strconcat (_tmp60_, _tmp63_, NULL);
				_g_free0 (s);
				s = _tmp64_;
				_g_free0 (_tmp63_);
				_vala_code_node_unref0 (type_arg);
			}
			_vala_iterable_unref0 (_type_arg_list);
		}
		_tmp65_ = s;
		_tmp66_ = g_strconcat (_tmp65_, ">", NULL);
		_g_free0 (s);
		s = _tmp66_;
	}
	_tmp67_ = self->priv->_nullable;
	if (_tmp67_) {
		const gchar* _tmp68_;
		gchar* _tmp69_;
		_tmp68_ = s;
		_tmp69_ = g_strconcat (_tmp68_, "?", NULL);
		_g_free0 (s);
		s = _tmp69_;
	}
	result = s;
	_vala_iterable_unref0 (type_args);
	return result;
}


gchar*
vala_data_type_to_qualified_string (ValaDataType* self,
                                    ValaScope* scope)
{
	g_return_val_if_fail (self != NULL, NULL);
	return VALA_DATA_TYPE_GET_CLASS (self)->to_qualified_string (self, scope);
}


/**
 * Creates a shallow copy of this type reference.
 *
 * @return copy of this type reference
 */
static ValaDataType*
vala_data_type_real_copy (ValaDataType* self)
{
	g_critical ("Type `%s' does not implement abstract method `vala_data_type_copy'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return NULL;
}


ValaDataType*
vala_data_type_copy (ValaDataType* self)
{
	g_return_val_if_fail (self != NULL, NULL);
	return VALA_DATA_TYPE_GET_CLASS (self)->copy (self);
}


/**
 * Checks two type references for equality. May only be used with
 * resolved type references.
 *
 * @param type2 a type reference
 * @return      true if this type reference is equal to type2, false
 *              otherwise
 */
static gboolean
vala_data_type_real_equals (ValaDataType* self,
                            ValaDataType* type2)
{
	gboolean result = FALSE;
	gboolean _tmp0_;
	gboolean _tmp1_;
	ValaTypeSymbol* _tmp2_;
	ValaTypeSymbol* _tmp3_;
	gboolean _tmp4_ = FALSE;
	gboolean _tmp10_;
	gboolean _tmp11_;
	ValaList* type_args = NULL;
	ValaList* _tmp12_;
	ValaList* type2_args = NULL;
	ValaList* _tmp13_;
	ValaList* _tmp14_;
	gint _tmp15_;
	gint _tmp16_;
	ValaList* _tmp17_;
	gint _tmp18_;
	gint _tmp19_;
	g_return_val_if_fail (type2 != NULL, FALSE);
	if (vala_data_type_is_disposable (type2) != vala_data_type_is_disposable (self)) {
		result = FALSE;
		return result;
	}
	_tmp0_ = type2->priv->_nullable;
	_tmp1_ = self->priv->_nullable;
	if (_tmp0_ != _tmp1_) {
		result = FALSE;
		return result;
	}
	_tmp2_ = type2->priv->_data_type;
	_tmp3_ = self->priv->_data_type;
	if (_tmp2_ != _tmp3_) {
		result = FALSE;
		return result;
	}
	if (G_TYPE_CHECK_INSTANCE_TYPE (type2, VALA_TYPE_GENERIC_TYPE)) {
		_tmp4_ = TRUE;
	} else {
		_tmp4_ = G_TYPE_CHECK_INSTANCE_TYPE (self, VALA_TYPE_GENERIC_TYPE);
	}
	if (_tmp4_) {
		gboolean _tmp5_ = FALSE;
		ValaTypeParameter* _tmp6_;
		ValaTypeParameter* _tmp7_;
		ValaTypeParameter* _tmp8_;
		ValaTypeParameter* _tmp9_;
		if (!G_TYPE_CHECK_INSTANCE_TYPE (type2, VALA_TYPE_GENERIC_TYPE)) {
			_tmp5_ = TRUE;
		} else {
			_tmp5_ = !G_TYPE_CHECK_INSTANCE_TYPE (self, VALA_TYPE_GENERIC_TYPE);
		}
		if (_tmp5_) {
			result = FALSE;
			return result;
		}
		_tmp6_ = vala_generic_type_get_type_parameter (G_TYPE_CHECK_INSTANCE_CAST (type2, VALA_TYPE_GENERIC_TYPE, ValaGenericType));
		_tmp7_ = _tmp6_;
		_tmp8_ = vala_generic_type_get_type_parameter (G_TYPE_CHECK_INSTANCE_CAST (self, VALA_TYPE_GENERIC_TYPE, ValaGenericType));
		_tmp9_ = _tmp8_;
		if (!vala_typeparameter_equals (_tmp7_, _tmp9_)) {
			result = FALSE;
			return result;
		}
	}
	_tmp10_ = type2->priv->_floating_reference;
	_tmp11_ = self->priv->_floating_reference;
	if (_tmp10_ != _tmp11_) {
		result = FALSE;
		return result;
	}
	_tmp12_ = vala_data_type_get_type_arguments (self);
	type_args = _tmp12_;
	_tmp13_ = vala_data_type_get_type_arguments (type2);
	type2_args = _tmp13_;
	_tmp14_ = type2_args;
	_tmp15_ = vala_collection_get_size ((ValaCollection*) _tmp14_);
	_tmp16_ = _tmp15_;
	_tmp17_ = type_args;
	_tmp18_ = vala_collection_get_size ((ValaCollection*) _tmp17_);
	_tmp19_ = _tmp18_;
	if (_tmp16_ != _tmp19_) {
		result = FALSE;
		_vala_iterable_unref0 (type2_args);
		_vala_iterable_unref0 (type_args);
		return result;
	}
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp20_ = FALSE;
			_tmp20_ = TRUE;
			while (TRUE) {
				gint _tmp22_;
				ValaList* _tmp23_;
				gint _tmp24_;
				gint _tmp25_;
				ValaList* _tmp26_;
				gint _tmp27_;
				gpointer _tmp28_;
				ValaDataType* _tmp29_;
				ValaList* _tmp30_;
				gint _tmp31_;
				gpointer _tmp32_;
				ValaDataType* _tmp33_;
				gboolean _tmp34_;
				if (!_tmp20_) {
					gint _tmp21_;
					_tmp21_ = i;
					i = _tmp21_ + 1;
				}
				_tmp20_ = FALSE;
				_tmp22_ = i;
				_tmp23_ = type_args;
				_tmp24_ = vala_collection_get_size ((ValaCollection*) _tmp23_);
				_tmp25_ = _tmp24_;
				if (!(_tmp22_ < _tmp25_)) {
					break;
				}
				_tmp26_ = type2_args;
				_tmp27_ = i;
				_tmp28_ = vala_list_get (_tmp26_, _tmp27_);
				_tmp29_ = (ValaDataType*) _tmp28_;
				_tmp30_ = type_args;
				_tmp31_ = i;
				_tmp32_ = vala_list_get (_tmp30_, _tmp31_);
				_tmp33_ = (ValaDataType*) _tmp32_;
				_tmp34_ = !vala_data_type_equals (_tmp29_, _tmp33_);
				_vala_code_node_unref0 (_tmp33_);
				_vala_code_node_unref0 (_tmp29_);
				if (_tmp34_) {
					result = FALSE;
					_vala_iterable_unref0 (type2_args);
					_vala_iterable_unref0 (type_args);
					return result;
				}
			}
		}
	}
	result = TRUE;
	_vala_iterable_unref0 (type2_args);
	_vala_iterable_unref0 (type_args);
	return result;
}


gboolean
vala_data_type_equals (ValaDataType* self,
                       ValaDataType* type2)
{
	g_return_val_if_fail (self != NULL, FALSE);
	return VALA_DATA_TYPE_GET_CLASS (self)->equals (self, type2);
}


/**
 * Checks whether this type reference is at least as strict as the
 * specified type reference type2.
 *
 * @param type2 a type reference
 * @return      true if this type reference is stricter or equal
 */
static gboolean
vala_data_type_real_stricter (ValaDataType* self,
                              ValaDataType* type2)
{
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_;
	gboolean _tmp3_ = FALSE;
	ValaTypeSymbol* _tmp4_;
	ValaTypeSymbol* _tmp5_;
	gboolean _tmp6_;
	gboolean _tmp7_;
	g_return_val_if_fail (type2 != NULL, FALSE);
	if (vala_data_type_is_disposable (type2) != vala_data_type_is_disposable (self)) {
		result = FALSE;
		return result;
	}
	_tmp1_ = type2->priv->_nullable;
	if (!_tmp1_) {
		gboolean _tmp2_;
		_tmp2_ = self->priv->_nullable;
		_tmp0_ = _tmp2_;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		result = FALSE;
		return result;
	}
	if (G_TYPE_CHECK_INSTANCE_TYPE (self, VALA_TYPE_GENERIC_TYPE)) {
		_tmp3_ = TRUE;
	} else {
		_tmp3_ = G_TYPE_CHECK_INSTANCE_TYPE (type2, VALA_TYPE_GENERIC_TYPE);
	}
	if (_tmp3_) {
		result = TRUE;
		return result;
	}
	_tmp4_ = type2->priv->_data_type;
	_tmp5_ = self->priv->_data_type;
	if (_tmp4_ != _tmp5_) {
		result = FALSE;
		return result;
	}
	_tmp6_ = type2->priv->_floating_reference;
	_tmp7_ = self->priv->_floating_reference;
	if (_tmp6_ != _tmp7_) {
		result = FALSE;
		return result;
	}
	result = TRUE;
	return result;
}


gboolean
vala_data_type_stricter (ValaDataType* self,
                         ValaDataType* type2)
{
	g_return_val_if_fail (self != NULL, FALSE);
	return VALA_DATA_TYPE_GET_CLASS (self)->stricter (self, type2);
}


static void
vala_data_type_real_replace_type (ValaCodeNode* base,
                                  ValaDataType* old_type,
                                  ValaDataType* new_type)
{
	ValaDataType * self;
	ValaList* _tmp0_;
	self = (ValaDataType*) base;
	g_return_if_fail (old_type != NULL);
	g_return_if_fail (new_type != NULL);
	_tmp0_ = self->priv->type_argument_list;
	if (_tmp0_ != NULL) {
		{
			gint i = 0;
			i = 0;
			{
				gboolean _tmp1_ = FALSE;
				_tmp1_ = TRUE;
				while (TRUE) {
					gint _tmp3_;
					ValaList* _tmp4_;
					gint _tmp5_;
					gint _tmp6_;
					ValaList* _tmp7_;
					gint _tmp8_;
					gpointer _tmp9_;
					ValaDataType* _tmp10_;
					gboolean _tmp11_;
					if (!_tmp1_) {
						gint _tmp2_;
						_tmp2_ = i;
						i = _tmp2_ + 1;
					}
					_tmp1_ = FALSE;
					_tmp3_ = i;
					_tmp4_ = self->priv->type_argument_list;
					_tmp5_ = vala_collection_get_size ((ValaCollection*) _tmp4_);
					_tmp6_ = _tmp5_;
					if (!(_tmp3_ < _tmp6_)) {
						break;
					}
					_tmp7_ = self->priv->type_argument_list;
					_tmp8_ = i;
					_tmp9_ = vala_list_get (_tmp7_, _tmp8_);
					_tmp10_ = (ValaDataType*) _tmp9_;
					_tmp11_ = _tmp10_ == old_type;
					_vala_code_node_unref0 (_tmp10_);
					if (_tmp11_) {
						ValaList* _tmp12_;
						gint _tmp13_;
						_tmp12_ = self->priv->type_argument_list;
						_tmp13_ = i;
						vala_list_set (_tmp12_, _tmp13_, new_type);
						return;
					}
				}
			}
		}
	}
}


static gboolean
vala_data_type_real_compatible (ValaDataType* self,
                                ValaDataType* target_type)
{
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	ValaCodeContext* _tmp2_;
	ValaCodeContext* _tmp3_;
	gboolean _tmp4_;
	gboolean _tmp5_;
	gboolean _tmp6_;
	gboolean _tmp9_ = FALSE;
	ValaCodeContext* _tmp10_;
	ValaCodeContext* _tmp11_;
	ValaProfile _tmp12_;
	ValaProfile _tmp13_;
	gboolean _tmp14_;
	gboolean _tmp37_ = FALSE;
	gboolean _tmp38_ = FALSE;
	ValaTypeSymbol* _tmp39_;
	gboolean _tmp42_ = FALSE;
	gboolean _tmp43_ = FALSE;
	ValaTypeSymbol* _tmp44_;
	gboolean _tmp74_ = FALSE;
	ValaTypeSymbol* _tmp75_;
	g_return_val_if_fail (target_type != NULL, FALSE);
	_tmp2_ = vala_code_context_get ();
	_tmp3_ = _tmp2_;
	_tmp4_ = vala_code_context_get_experimental_non_null (_tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = _tmp5_;
	_vala_code_context_unref0 (_tmp3_);
	if (_tmp6_) {
		gboolean _tmp7_;
		_tmp7_ = self->priv->_nullable;
		_tmp1_ = _tmp7_;
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		gboolean _tmp8_;
		_tmp8_ = target_type->priv->_nullable;
		_tmp0_ = !_tmp8_;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		result = FALSE;
		return result;
	}
	_tmp10_ = vala_code_context_get ();
	_tmp11_ = _tmp10_;
	_tmp12_ = vala_code_context_get_profile (_tmp11_);
	_tmp13_ = _tmp12_;
	_tmp14_ = _tmp13_ == VALA_PROFILE_GOBJECT;
	_vala_code_context_unref0 (_tmp11_);
	if (_tmp14_) {
		ValaTypeSymbol* _tmp15_;
		_tmp15_ = target_type->priv->_data_type;
		_tmp9_ = _tmp15_ != NULL;
	} else {
		_tmp9_ = FALSE;
	}
	if (_tmp9_) {
		ValaTypeSymbol* _tmp16_;
		ValaCodeContext* _tmp17_;
		ValaCodeContext* _tmp18_;
		ValaSemanticAnalyzer* _tmp19_;
		ValaSemanticAnalyzer* _tmp20_;
		ValaStructValueType* _tmp21_;
		ValaTypeSymbol* _tmp22_;
		gboolean _tmp23_;
		ValaTypeSymbol* _tmp24_;
		ValaCodeContext* _tmp25_;
		ValaCodeContext* _tmp26_;
		ValaSemanticAnalyzer* _tmp27_;
		ValaSemanticAnalyzer* _tmp28_;
		ValaObjectType* _tmp29_;
		ValaTypeSymbol* _tmp30_;
		gboolean _tmp31_;
		_tmp16_ = target_type->priv->_data_type;
		_tmp17_ = vala_code_context_get ();
		_tmp18_ = _tmp17_;
		_tmp19_ = vala_code_context_get_analyzer (_tmp18_);
		_tmp20_ = _tmp19_;
		_tmp21_ = _tmp20_->gvalue_type;
		_tmp22_ = ((ValaDataType*) _tmp21_)->priv->_data_type;
		_tmp23_ = vala_typesymbol_is_subtype_of (_tmp16_, _tmp22_);
		_vala_code_context_unref0 (_tmp18_);
		if (_tmp23_) {
			result = TRUE;
			return result;
		}
		_tmp24_ = target_type->priv->_data_type;
		_tmp25_ = vala_code_context_get ();
		_tmp26_ = _tmp25_;
		_tmp27_ = vala_code_context_get_analyzer (_tmp26_);
		_tmp28_ = _tmp27_;
		_tmp29_ = _tmp28_->gvariant_type;
		_tmp30_ = ((ValaDataType*) _tmp29_)->priv->_data_type;
		_tmp31_ = vala_typesymbol_is_subtype_of (_tmp24_, _tmp30_);
		_vala_code_context_unref0 (_tmp26_);
		if (_tmp31_) {
			result = TRUE;
			return result;
		}
	}
	if (G_TYPE_CHECK_INSTANCE_TYPE (target_type, VALA_TYPE_POINTER_TYPE)) {
		gboolean _tmp32_ = FALSE;
		if (G_TYPE_CHECK_INSTANCE_TYPE (self, VALA_TYPE_GENERIC_TYPE)) {
			_tmp32_ = TRUE;
		} else {
			gboolean _tmp33_ = FALSE;
			ValaTypeSymbol* _tmp34_;
			_tmp34_ = self->priv->_data_type;
			if (_tmp34_ != NULL) {
				gboolean _tmp35_ = FALSE;
				ValaTypeSymbol* _tmp36_;
				_tmp36_ = self->priv->_data_type;
				if (vala_typesymbol_is_reference_type (_tmp36_)) {
					_tmp35_ = TRUE;
				} else {
					_tmp35_ = G_TYPE_CHECK_INSTANCE_TYPE (self, VALA_TYPE_DELEGATE_TYPE);
				}
				_tmp33_ = _tmp35_;
			} else {
				_tmp33_ = FALSE;
			}
			_tmp32_ = _tmp33_;
		}
		if (_tmp32_) {
			result = TRUE;
			return result;
		}
		result = FALSE;
		return result;
	}
	if (G_TYPE_CHECK_INSTANCE_TYPE (target_type, VALA_TYPE_GENERIC_TYPE)) {
		result = TRUE;
		return result;
	}
	if (G_TYPE_CHECK_INSTANCE_TYPE (self, VALA_TYPE_ARRAY_TYPE) != G_TYPE_CHECK_INSTANCE_TYPE (target_type, VALA_TYPE_ARRAY_TYPE)) {
		result = FALSE;
		return result;
	}
	_tmp39_ = self->priv->_data_type;
	if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp39_, VALA_TYPE_ENUM)) {
		ValaTypeSymbol* _tmp40_;
		_tmp40_ = target_type->priv->_data_type;
		_tmp38_ = G_TYPE_CHECK_INSTANCE_TYPE (_tmp40_, VALA_TYPE_STRUCT);
	} else {
		_tmp38_ = FALSE;
	}
	if (_tmp38_) {
		ValaTypeSymbol* _tmp41_;
		_tmp41_ = target_type->priv->_data_type;
		_tmp37_ = vala_struct_is_integer_type (G_TYPE_CHECK_INSTANCE_CAST (_tmp41_, VALA_TYPE_STRUCT, ValaStruct));
	} else {
		_tmp37_ = FALSE;
	}
	if (_tmp37_) {
		result = TRUE;
		return result;
	}
	_tmp44_ = self->priv->_data_type;
	if (_tmp44_ != NULL) {
		ValaTypeSymbol* _tmp45_;
		_tmp45_ = target_type->priv->_data_type;
		_tmp43_ = _tmp45_ != NULL;
	} else {
		_tmp43_ = FALSE;
	}
	if (_tmp43_) {
		ValaTypeSymbol* _tmp46_;
		ValaTypeSymbol* _tmp47_;
		_tmp46_ = self->priv->_data_type;
		_tmp47_ = target_type->priv->_data_type;
		_tmp42_ = vala_typesymbol_is_subtype_of (_tmp46_, _tmp47_);
	} else {
		_tmp42_ = FALSE;
	}
	if (_tmp42_) {
		ValaDataType* base_type = NULL;
		ValaTypeSymbol* _tmp48_;
		ValaDataType* _tmp49_;
		ValaList* base_type_args = NULL;
		ValaDataType* _tmp50_;
		ValaList* _tmp51_;
		ValaList* target_type_args = NULL;
		ValaList* _tmp52_;
		ValaList* _tmp53_;
		gint _tmp54_;
		gint _tmp55_;
		ValaList* _tmp56_;
		gint _tmp57_;
		gint _tmp58_;
		_tmp48_ = target_type->priv->_data_type;
		_tmp49_ = vala_semantic_analyzer_get_instance_base_type_for_member (self, _tmp48_, (ValaCodeNode*) self);
		base_type = _tmp49_;
		_tmp50_ = base_type;
		_tmp51_ = vala_data_type_get_type_arguments (_tmp50_);
		base_type_args = _tmp51_;
		_tmp52_ = vala_data_type_get_type_arguments (target_type);
		target_type_args = _tmp52_;
		_tmp53_ = base_type_args;
		_tmp54_ = vala_collection_get_size ((ValaCollection*) _tmp53_);
		_tmp55_ = _tmp54_;
		_tmp56_ = target_type_args;
		_tmp57_ = vala_collection_get_size ((ValaCollection*) _tmp56_);
		_tmp58_ = _tmp57_;
		if (_tmp55_ == _tmp58_) {
			{
				gint i = 0;
				i = 0;
				{
					gboolean _tmp59_ = FALSE;
					_tmp59_ = TRUE;
					while (TRUE) {
						gint _tmp61_;
						ValaList* _tmp62_;
						gint _tmp63_;
						gint _tmp64_;
						ValaList* _tmp65_;
						gint _tmp66_;
						gpointer _tmp67_;
						ValaDataType* _tmp68_;
						ValaList* _tmp69_;
						gint _tmp70_;
						gpointer _tmp71_;
						ValaDataType* _tmp72_;
						gboolean _tmp73_;
						if (!_tmp59_) {
							gint _tmp60_;
							_tmp60_ = i;
							i = _tmp60_ + 1;
						}
						_tmp59_ = FALSE;
						_tmp61_ = i;
						_tmp62_ = base_type_args;
						_tmp63_ = vala_collection_get_size ((ValaCollection*) _tmp62_);
						_tmp64_ = _tmp63_;
						if (!(_tmp61_ < _tmp64_)) {
							break;
						}
						_tmp65_ = base_type_args;
						_tmp66_ = i;
						_tmp67_ = vala_list_get (_tmp65_, _tmp66_);
						_tmp68_ = (ValaDataType*) _tmp67_;
						_tmp69_ = target_type_args;
						_tmp70_ = i;
						_tmp71_ = vala_list_get (_tmp69_, _tmp70_);
						_tmp72_ = (ValaDataType*) _tmp71_;
						_tmp73_ = !vala_data_type_compatible (_tmp68_, _tmp72_);
						_vala_code_node_unref0 (_tmp72_);
						_vala_code_node_unref0 (_tmp68_);
						if (_tmp73_) {
							result = FALSE;
							_vala_iterable_unref0 (target_type_args);
							_vala_iterable_unref0 (base_type_args);
							_vala_code_node_unref0 (base_type);
							return result;
						}
					}
				}
			}
		}
		result = TRUE;
		_vala_iterable_unref0 (target_type_args);
		_vala_iterable_unref0 (base_type_args);
		_vala_code_node_unref0 (base_type);
		return result;
	}
	_tmp75_ = self->priv->_data_type;
	if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp75_, VALA_TYPE_STRUCT)) {
		ValaTypeSymbol* _tmp76_;
		_tmp76_ = target_type->priv->_data_type;
		_tmp74_ = G_TYPE_CHECK_INSTANCE_TYPE (_tmp76_, VALA_TYPE_STRUCT);
	} else {
		_tmp74_ = FALSE;
	}
	if (_tmp74_) {
		ValaStruct* expr_struct = NULL;
		ValaTypeSymbol* _tmp77_;
		ValaStruct* _tmp78_;
		ValaStruct* expect_struct = NULL;
		ValaTypeSymbol* _tmp79_;
		ValaStruct* _tmp80_;
		gboolean _tmp81_ = FALSE;
		ValaStruct* _tmp82_;
		gboolean _tmp84_ = FALSE;
		gboolean _tmp85_ = FALSE;
		ValaStruct* _tmp86_;
		_tmp77_ = self->priv->_data_type;
		_tmp78_ = _vala_code_node_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp77_, VALA_TYPE_STRUCT, ValaStruct));
		expr_struct = _tmp78_;
		_tmp79_ = target_type->priv->_data_type;
		_tmp80_ = _vala_code_node_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp79_, VALA_TYPE_STRUCT, ValaStruct));
		expect_struct = _tmp80_;
		_tmp82_ = expr_struct;
		if (vala_struct_is_integer_type (_tmp82_)) {
			ValaStruct* _tmp83_;
			_tmp83_ = expect_struct;
			_tmp81_ = vala_struct_is_floating_type (_tmp83_);
		} else {
			_tmp81_ = FALSE;
		}
		if (_tmp81_) {
			result = TRUE;
			_vala_code_node_unref0 (expect_struct);
			_vala_code_node_unref0 (expr_struct);
			return result;
		}
		_tmp86_ = expr_struct;
		if (vala_struct_is_integer_type (_tmp86_)) {
			ValaStruct* _tmp87_;
			_tmp87_ = expect_struct;
			_tmp85_ = vala_struct_is_integer_type (_tmp87_);
		} else {
			_tmp85_ = FALSE;
		}
		if (_tmp85_) {
			_tmp84_ = TRUE;
		} else {
			gboolean _tmp88_ = FALSE;
			ValaStruct* _tmp89_;
			_tmp89_ = expr_struct;
			if (vala_struct_is_floating_type (_tmp89_)) {
				ValaStruct* _tmp90_;
				_tmp90_ = expect_struct;
				_tmp88_ = vala_struct_is_floating_type (_tmp90_);
			} else {
				_tmp88_ = FALSE;
			}
			_tmp84_ = _tmp88_;
		}
		if (_tmp84_) {
			ValaStruct* _tmp91_;
			gint _tmp92_;
			gint _tmp93_;
			ValaStruct* _tmp94_;
			gint _tmp95_;
			gint _tmp96_;
			_tmp91_ = expr_struct;
			_tmp92_ = vala_struct_get_rank (_tmp91_);
			_tmp93_ = _tmp92_;
			_tmp94_ = expect_struct;
			_tmp95_ = vala_struct_get_rank (_tmp94_);
			_tmp96_ = _tmp95_;
			if (_tmp93_ <= _tmp96_) {
				result = TRUE;
				_vala_code_node_unref0 (expect_struct);
				_vala_code_node_unref0 (expr_struct);
				return result;
			}
		}
		_vala_code_node_unref0 (expect_struct);
		_vala_code_node_unref0 (expr_struct);
	}
	result = FALSE;
	return result;
}


gboolean
vala_data_type_compatible (ValaDataType* self,
                           ValaDataType* target_type)
{
	g_return_val_if_fail (self != NULL, FALSE);
	return VALA_DATA_TYPE_GET_CLASS (self)->compatible (self, target_type);
}


/**
 * Returns whether instances of this type are invokable.
 *
 * @return true if invokable, false otherwise
 */
static gboolean
vala_data_type_real_is_invokable (ValaDataType* self)
{
	gboolean result = FALSE;
	result = FALSE;
	return result;
}


gboolean
vala_data_type_is_invokable (ValaDataType* self)
{
	g_return_val_if_fail (self != NULL, FALSE);
	return VALA_DATA_TYPE_GET_CLASS (self)->is_invokable (self);
}


/**
 * Returns the return type of this invokable.
 *
 * @return return type
 */
static ValaDataType*
vala_data_type_real_get_return_type (ValaDataType* self)
{
	ValaDataType* result = NULL;
	result = NULL;
	return result;
}


ValaDataType*
vala_data_type_get_return_type (ValaDataType* self)
{
	g_return_val_if_fail (self != NULL, NULL);
	return VALA_DATA_TYPE_GET_CLASS (self)->get_return_type (self);
}


/**
 * Returns copy of the list of invocation parameters.
 *
 * @return parameter list
 */
static ValaList*
vala_data_type_real_get_parameters (ValaDataType* self)
{
	ValaList* result = NULL;
	result = NULL;
	return result;
}


ValaList*
vala_data_type_get_parameters (ValaDataType* self)
{
	g_return_val_if_fail (self != NULL, NULL);
	return VALA_DATA_TYPE_GET_CLASS (self)->get_parameters (self);
}


static gboolean
vala_data_type_real_is_reference_type_or_type_parameter (ValaDataType* self)
{
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	ValaTypeSymbol* _tmp2_;
	_tmp2_ = self->priv->_data_type;
	if (_tmp2_ != NULL) {
		ValaTypeSymbol* _tmp3_;
		_tmp3_ = self->priv->_data_type;
		_tmp1_ = vala_typesymbol_is_reference_type (_tmp3_);
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = G_TYPE_CHECK_INSTANCE_TYPE (self, VALA_TYPE_GENERIC_TYPE);
	}
	result = _tmp0_;
	return result;
}


gboolean
vala_data_type_is_reference_type_or_type_parameter (ValaDataType* self)
{
	g_return_val_if_fail (self != NULL, FALSE);
	return VALA_DATA_TYPE_GET_CLASS (self)->is_reference_type_or_type_parameter (self);
}


static gboolean
vala_data_type_real_is_array (ValaDataType* self)
{
	gboolean result = FALSE;
	result = FALSE;
	return result;
}


gboolean
vala_data_type_is_array (ValaDataType* self)
{
	g_return_val_if_fail (self != NULL, FALSE);
	return VALA_DATA_TYPE_GET_CLASS (self)->is_array (self);
}


static gboolean
vala_data_type_real_is_accessible (ValaDataType* self,
                                   ValaSymbol* sym)
{
	gboolean result = FALSE;
	ValaTypeSymbol* _tmp11_;
	g_return_val_if_fail (sym != NULL, FALSE);
	{
		ValaList* _type_arg_list = NULL;
		ValaList* _tmp0_;
		gint _type_arg_size = 0;
		ValaList* _tmp1_;
		gint _tmp2_;
		gint _tmp3_;
		gint _type_arg_index = 0;
		_tmp0_ = vala_data_type_get_type_arguments (self);
		_type_arg_list = _tmp0_;
		_tmp1_ = _type_arg_list;
		_tmp2_ = vala_collection_get_size ((ValaCollection*) _tmp1_);
		_tmp3_ = _tmp2_;
		_type_arg_size = _tmp3_;
		_type_arg_index = -1;
		while (TRUE) {
			gint _tmp4_;
			gint _tmp5_;
			gint _tmp6_;
			ValaDataType* type_arg = NULL;
			ValaList* _tmp7_;
			gint _tmp8_;
			gpointer _tmp9_;
			ValaDataType* _tmp10_;
			_tmp4_ = _type_arg_index;
			_type_arg_index = _tmp4_ + 1;
			_tmp5_ = _type_arg_index;
			_tmp6_ = _type_arg_size;
			if (!(_tmp5_ < _tmp6_)) {
				break;
			}
			_tmp7_ = _type_arg_list;
			_tmp8_ = _type_arg_index;
			_tmp9_ = vala_list_get (_tmp7_, _tmp8_);
			type_arg = (ValaDataType*) _tmp9_;
			_tmp10_ = type_arg;
			if (!vala_data_type_is_accessible (_tmp10_, sym)) {
				result = FALSE;
				_vala_code_node_unref0 (type_arg);
				_vala_iterable_unref0 (_type_arg_list);
				return result;
			}
			_vala_code_node_unref0 (type_arg);
		}
		_vala_iterable_unref0 (_type_arg_list);
	}
	_tmp11_ = self->priv->_data_type;
	if (_tmp11_ != NULL) {
		ValaTypeSymbol* _tmp12_;
		_tmp12_ = self->priv->_data_type;
		result = vala_symbol_is_accessible ((ValaSymbol*) _tmp12_, sym);
		return result;
	}
	result = TRUE;
	return result;
}


gboolean
vala_data_type_is_accessible (ValaDataType* self,
                              ValaSymbol* sym)
{
	g_return_val_if_fail (self != NULL, FALSE);
	return VALA_DATA_TYPE_GET_CLASS (self)->is_accessible (self, sym);
}


static ValaSymbol*
vala_data_type_real_get_member (ValaDataType* self,
                                const gchar* member_name)
{
	ValaSymbol* result = NULL;
	ValaTypeSymbol* _tmp0_;
	g_return_val_if_fail (member_name != NULL, NULL);
	_tmp0_ = self->priv->_data_type;
	if (_tmp0_ != NULL) {
		ValaTypeSymbol* _tmp1_;
		ValaSymbol* _tmp2_;
		_tmp1_ = self->priv->_data_type;
		_tmp2_ = vala_semantic_analyzer_symbol_lookup_inherited ((ValaSymbol*) _tmp1_, member_name);
		result = _tmp2_;
		return result;
	}
	result = NULL;
	return result;
}


ValaSymbol*
vala_data_type_get_member (ValaDataType* self,
                           const gchar* member_name)
{
	g_return_val_if_fail (self != NULL, NULL);
	return VALA_DATA_TYPE_GET_CLASS (self)->get_member (self, member_name);
}


static ValaSymbol*
vala_data_type_real_get_pointer_member (ValaDataType* self,
                                        const gchar* member_name)
{
	ValaSymbol* result = NULL;
	g_return_val_if_fail (member_name != NULL, NULL);
	result = NULL;
	return result;
}


ValaSymbol*
vala_data_type_get_pointer_member (ValaDataType* self,
                                   const gchar* member_name)
{
	g_return_val_if_fail (self != NULL, NULL);
	return VALA_DATA_TYPE_GET_CLASS (self)->get_pointer_member (self, member_name);
}


/**
 * Checks whether this data type references a real struct. A real struct
 * is a struct which is not a simple (fundamental) type.
 */
static gboolean
vala_data_type_real_is_real_struct_type (ValaDataType* self)
{
	gboolean result = FALSE;
	ValaStruct* s = NULL;
	ValaTypeSymbol* _tmp0_;
	ValaStruct* _tmp1_;
	gboolean _tmp2_ = FALSE;
	ValaStruct* _tmp3_;
	_tmp0_ = self->priv->_data_type;
	_tmp1_ = _vala_code_node_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp0_, VALA_TYPE_STRUCT) ? ((ValaStruct*) _tmp0_) : NULL);
	s = _tmp1_;
	_tmp3_ = s;
	if (_tmp3_ != NULL) {
		ValaStruct* _tmp4_;
		_tmp4_ = s;
		_tmp2_ = !vala_struct_is_simple_type (_tmp4_);
	} else {
		_tmp2_ = FALSE;
	}
	if (_tmp2_) {
		result = TRUE;
		_vala_code_node_unref0 (s);
		return result;
	}
	result = FALSE;
	_vala_code_node_unref0 (s);
	return result;
}


gboolean
vala_data_type_is_real_struct_type (ValaDataType* self)
{
	g_return_val_if_fail (self != NULL, FALSE);
	return VALA_DATA_TYPE_GET_CLASS (self)->is_real_struct_type (self);
}


gboolean
vala_data_type_is_real_non_null_struct_type (ValaDataType* self)
{
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	if (vala_data_type_is_real_struct_type (self)) {
		gboolean _tmp1_;
		_tmp1_ = self->priv->_nullable;
		_tmp0_ = !_tmp1_;
	} else {
		_tmp0_ = FALSE;
	}
	result = _tmp0_;
	return result;
}


/**
 * Returns whether the value needs to be disposed, i.e. whether
 * allocated memory or other resources need to be released when
 * the value is no longer needed.
 */
static gboolean
vala_data_type_real_is_disposable (ValaDataType* self)
{
	gboolean result = FALSE;
	gboolean _tmp0_;
	_tmp0_ = self->priv->_value_owned;
	if (!_tmp0_) {
		result = FALSE;
		return result;
	}
	if (vala_data_type_is_reference_type_or_type_parameter (self)) {
		result = TRUE;
		return result;
	}
	result = FALSE;
	return result;
}


gboolean
vala_data_type_is_disposable (ValaDataType* self)
{
	g_return_val_if_fail (self != NULL, FALSE);
	return VALA_DATA_TYPE_GET_CLASS (self)->is_disposable (self);
}


static ValaDataType*
vala_data_type_real_get_actual_type (ValaDataType* self,
                                     ValaDataType* derived_instance_type,
                                     ValaList* method_type_arguments,
                                     ValaCodeNode* node_reference)
{
	ValaDataType* result = NULL;
	ValaDataType* _result_ = NULL;
	ValaDataType* _tmp0_;
	gboolean _tmp1_ = FALSE;
	ValaDataType* _tmp2_;
	g_return_val_if_fail (node_reference != NULL, NULL);
	_tmp0_ = vala_data_type_copy (self);
	_result_ = _tmp0_;
	if (derived_instance_type == NULL) {
		_tmp1_ = method_type_arguments == NULL;
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		result = _result_;
		return result;
	}
	_tmp2_ = _result_;
	if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp2_, VALA_TYPE_GENERIC_TYPE)) {
		ValaDataType* _tmp3_;
		ValaDataType* _tmp4_;
		_tmp3_ = _result_;
		_tmp4_ = vala_semantic_analyzer_get_actual_type (derived_instance_type, method_type_arguments, G_TYPE_CHECK_INSTANCE_CAST (_tmp3_, VALA_TYPE_GENERIC_TYPE, ValaGenericType), node_reference);
		_vala_code_node_unref0 (_result_);
		_result_ = _tmp4_;
	} else {
		ValaDataType* _tmp5_;
		ValaList* _tmp6_;
		_tmp5_ = _result_;
		_tmp6_ = _tmp5_->priv->type_argument_list;
		if (_tmp6_ != NULL) {
			{
				gint i = 0;
				i = 0;
				{
					gboolean _tmp7_ = FALSE;
					_tmp7_ = TRUE;
					while (TRUE) {
						gint _tmp9_;
						ValaDataType* _tmp10_;
						ValaList* _tmp11_;
						gint _tmp12_;
						gint _tmp13_;
						ValaDataType* _tmp14_;
						ValaList* _tmp15_;
						gint _tmp16_;
						ValaDataType* _tmp17_;
						ValaList* _tmp18_;
						gint _tmp19_;
						gpointer _tmp20_;
						ValaDataType* _tmp21_;
						ValaDataType* _tmp22_;
						ValaDataType* _tmp23_;
						if (!_tmp7_) {
							gint _tmp8_;
							_tmp8_ = i;
							i = _tmp8_ + 1;
						}
						_tmp7_ = FALSE;
						_tmp9_ = i;
						_tmp10_ = _result_;
						_tmp11_ = _tmp10_->priv->type_argument_list;
						_tmp12_ = vala_collection_get_size ((ValaCollection*) _tmp11_);
						_tmp13_ = _tmp12_;
						if (!(_tmp9_ < _tmp13_)) {
							break;
						}
						_tmp14_ = _result_;
						_tmp15_ = _tmp14_->priv->type_argument_list;
						_tmp16_ = i;
						_tmp17_ = _result_;
						_tmp18_ = _tmp17_->priv->type_argument_list;
						_tmp19_ = i;
						_tmp20_ = vala_list_get (_tmp18_, _tmp19_);
						_tmp21_ = (ValaDataType*) _tmp20_;
						_tmp22_ = vala_data_type_get_actual_type (_tmp21_, derived_instance_type, method_type_arguments, node_reference);
						_tmp23_ = _tmp22_;
						vala_list_set (_tmp15_, _tmp16_, _tmp23_);
						_vala_code_node_unref0 (_tmp23_);
						_vala_code_node_unref0 (_tmp21_);
					}
				}
			}
		}
	}
	result = _result_;
	return result;
}


ValaDataType*
vala_data_type_get_actual_type (ValaDataType* self,
                                ValaDataType* derived_instance_type,
                                ValaList* method_type_arguments,
                                ValaCodeNode* node_reference)
{
	g_return_val_if_fail (self != NULL, NULL);
	return VALA_DATA_TYPE_GET_CLASS (self)->get_actual_type (self, derived_instance_type, method_type_arguments, node_reference);
}


/**
 * Search for the type parameter in this formal type and match it in
 * value_type.
 */
static ValaDataType*
vala_data_type_real_infer_type_argument (ValaDataType* self,
                                         ValaTypeParameter* type_param,
                                         ValaDataType* value_type)
{
	ValaDataType* result = NULL;
	ValaIterator* value_type_arg_it = NULL;
	ValaList* _tmp0_;
	ValaList* _tmp1_;
	ValaIterator* _tmp2_;
	ValaIterator* _tmp3_;
	g_return_val_if_fail (type_param != NULL, NULL);
	g_return_val_if_fail (value_type != NULL, NULL);
	_tmp0_ = vala_data_type_get_type_arguments (value_type);
	_tmp1_ = _tmp0_;
	_tmp2_ = vala_iterable_iterator ((ValaIterable*) _tmp1_);
	_tmp3_ = _tmp2_;
	_vala_iterable_unref0 (_tmp1_);
	value_type_arg_it = _tmp3_;
	{
		ValaList* _formal_type_arg_list = NULL;
		ValaList* _tmp4_;
		gint _formal_type_arg_size = 0;
		ValaList* _tmp5_;
		gint _tmp6_;
		gint _tmp7_;
		gint _formal_type_arg_index = 0;
		_tmp4_ = vala_data_type_get_type_arguments (self);
		_formal_type_arg_list = _tmp4_;
		_tmp5_ = _formal_type_arg_list;
		_tmp6_ = vala_collection_get_size ((ValaCollection*) _tmp5_);
		_tmp7_ = _tmp6_;
		_formal_type_arg_size = _tmp7_;
		_formal_type_arg_index = -1;
		while (TRUE) {
			gint _tmp8_;
			gint _tmp9_;
			gint _tmp10_;
			ValaDataType* formal_type_arg = NULL;
			ValaList* _tmp11_;
			gint _tmp12_;
			gpointer _tmp13_;
			ValaIterator* _tmp14_;
			_tmp8_ = _formal_type_arg_index;
			_formal_type_arg_index = _tmp8_ + 1;
			_tmp9_ = _formal_type_arg_index;
			_tmp10_ = _formal_type_arg_size;
			if (!(_tmp9_ < _tmp10_)) {
				break;
			}
			_tmp11_ = _formal_type_arg_list;
			_tmp12_ = _formal_type_arg_index;
			_tmp13_ = vala_list_get (_tmp11_, _tmp12_);
			formal_type_arg = (ValaDataType*) _tmp13_;
			_tmp14_ = value_type_arg_it;
			if (vala_iterator_next (_tmp14_)) {
				ValaDataType* inferred_type = NULL;
				ValaDataType* _tmp15_;
				ValaIterator* _tmp16_;
				gpointer _tmp17_;
				ValaDataType* _tmp18_;
				ValaDataType* _tmp19_;
				ValaDataType* _tmp20_;
				ValaDataType* _tmp21_;
				_tmp15_ = formal_type_arg;
				_tmp16_ = value_type_arg_it;
				_tmp17_ = vala_iterator_get (_tmp16_);
				_tmp18_ = (ValaDataType*) _tmp17_;
				_tmp19_ = vala_data_type_infer_type_argument (_tmp15_, type_param, _tmp18_);
				_tmp20_ = _tmp19_;
				_vala_code_node_unref0 (_tmp18_);
				inferred_type = _tmp20_;
				_tmp21_ = inferred_type;
				if (_tmp21_ != NULL) {
					result = inferred_type;
					_vala_code_node_unref0 (formal_type_arg);
					_vala_iterable_unref0 (_formal_type_arg_list);
					_vala_iterator_unref0 (value_type_arg_it);
					return result;
				}
				_vala_code_node_unref0 (inferred_type);
			}
			_vala_code_node_unref0 (formal_type_arg);
		}
		_vala_iterable_unref0 (_formal_type_arg_list);
	}
	result = NULL;
	_vala_iterator_unref0 (value_type_arg_it);
	return result;
}


ValaDataType*
vala_data_type_infer_type_argument (ValaDataType* self,
                                    ValaTypeParameter* type_param,
                                    ValaDataType* value_type)
{
	g_return_val_if_fail (self != NULL, NULL);
	return VALA_DATA_TYPE_GET_CLASS (self)->infer_type_argument (self, type_param, value_type);
}


/**
 * Returns a stringified representation used for detailed error output
 *
 * @param override_name used as name if given
 * @return stringified representation
 */
static gchar*
vala_data_type_real_to_prototype_string (ValaDataType* self,
                                         const gchar* override_name)
{
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	if (vala_data_type_is_weak (self)) {
		_tmp0_ = "unowned ";
	} else {
		_tmp0_ = "";
	}
	_tmp1_ = vala_data_type_to_qualified_string (self, NULL);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_strdup_printf ("%s%s", _tmp0_, _tmp2_);
	_tmp4_ = _tmp3_;
	_g_free0 (_tmp2_);
	result = _tmp4_;
	return result;
}


gchar*
vala_data_type_to_prototype_string (ValaDataType* self,
                                    const gchar* override_name)
{
	g_return_val_if_fail (self != NULL, NULL);
	return VALA_DATA_TYPE_GET_CLASS (self)->to_prototype_string (self, override_name);
}


gboolean
vala_data_type_is_weak (ValaDataType* self)
{
	gboolean result = FALSE;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_value_owned;
	if (_tmp0_) {
		result = FALSE;
		return result;
	} else {
		gboolean _tmp1_ = FALSE;
		if (G_TYPE_CHECK_INSTANCE_TYPE (self, VALA_TYPE_VOID_TYPE)) {
			_tmp1_ = TRUE;
		} else {
			_tmp1_ = G_TYPE_CHECK_INSTANCE_TYPE (self, VALA_TYPE_POINTER_TYPE);
		}
		if (_tmp1_) {
			result = FALSE;
			return result;
		} else {
			if (G_TYPE_CHECK_INSTANCE_TYPE (self, VALA_TYPE_VALUE_TYPE)) {
				gboolean _tmp2_;
				_tmp2_ = self->priv->_nullable;
				if (_tmp2_) {
					result = TRUE;
					return result;
				}
				result = FALSE;
				return result;
			}
		}
	}
	result = TRUE;
	return result;
}


ValaDataType*
vala_data_type_construct (GType object_type)
{
	ValaDataType* self = NULL;
	self = (ValaDataType*) vala_code_node_construct (object_type);
	return self;
}


gboolean
vala_data_type_get_value_owned (ValaDataType* self)
{
	gboolean result;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_value_owned;
	result = _tmp0_;
	return result;
}


void
vala_data_type_set_value_owned (ValaDataType* self,
                                gboolean value)
{
	g_return_if_fail (self != NULL);
	self->priv->_value_owned = value;
}


gboolean
vala_data_type_get_nullable (ValaDataType* self)
{
	gboolean result;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_nullable;
	result = _tmp0_;
	return result;
}


void
vala_data_type_set_nullable (ValaDataType* self,
                             gboolean value)
{
	g_return_if_fail (self != NULL);
	self->priv->_nullable = value;
}


ValaTypeSymbol*
vala_data_type_get_data_type (ValaDataType* self)
{
	ValaTypeSymbol* result;
	ValaTypeSymbol* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_data_type;
	result = _tmp0_;
	return result;
}


void
vala_data_type_set_data_type (ValaDataType* self,
                              ValaTypeSymbol* value)
{
	g_return_if_fail (self != NULL);
	self->priv->_data_type = value;
}


gboolean
vala_data_type_get_floating_reference (ValaDataType* self)
{
	gboolean result;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_floating_reference;
	result = _tmp0_;
	return result;
}


void
vala_data_type_set_floating_reference (ValaDataType* self,
                                       gboolean value)
{
	g_return_if_fail (self != NULL);
	self->priv->_floating_reference = value;
}


gboolean
vala_data_type_get_is_dynamic (ValaDataType* self)
{
	gboolean result;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_is_dynamic;
	result = _tmp0_;
	return result;
}


void
vala_data_type_set_is_dynamic (ValaDataType* self,
                               gboolean value)
{
	g_return_if_fail (self != NULL);
	self->priv->_is_dynamic = value;
}


static void
vala_data_type_class_init (ValaDataTypeClass * klass)
{
	vala_data_type_parent_class = g_type_class_peek_parent (klass);
	((ValaCodeNodeClass *) klass)->finalize = vala_data_type_finalize;
	g_type_class_adjust_private_offset (klass, &ValaDataType_private_offset);
	((ValaCodeNodeClass *) klass)->accept = (void (*) (ValaCodeNode *, ValaCodeVisitor*)) vala_data_type_real_accept;
	((ValaCodeNodeClass *) klass)->accept_children = (void (*) (ValaCodeNode *, ValaCodeVisitor*)) vala_data_type_real_accept_children;
	((ValaCodeNodeClass *) klass)->to_string = (gchar* (*) (ValaCodeNode *)) vala_data_type_real_to_string;
	((ValaDataTypeClass *) klass)->to_qualified_string = (gchar* (*) (ValaDataType *, ValaScope*)) vala_data_type_real_to_qualified_string;
	((ValaDataTypeClass *) klass)->copy = (ValaDataType* (*) (ValaDataType *)) vala_data_type_real_copy;
	((ValaDataTypeClass *) klass)->equals = (gboolean (*) (ValaDataType *, ValaDataType*)) vala_data_type_real_equals;
	((ValaDataTypeClass *) klass)->stricter = (gboolean (*) (ValaDataType *, ValaDataType*)) vala_data_type_real_stricter;
	((ValaCodeNodeClass *) klass)->replace_type = (void (*) (ValaCodeNode *, ValaDataType*, ValaDataType*)) vala_data_type_real_replace_type;
	((ValaDataTypeClass *) klass)->compatible = (gboolean (*) (ValaDataType *, ValaDataType*)) vala_data_type_real_compatible;
	((ValaDataTypeClass *) klass)->is_invokable = (gboolean (*) (ValaDataType *)) vala_data_type_real_is_invokable;
	((ValaDataTypeClass *) klass)->get_return_type = (ValaDataType* (*) (ValaDataType *)) vala_data_type_real_get_return_type;
	((ValaDataTypeClass *) klass)->get_parameters = (ValaList* (*) (ValaDataType *)) vala_data_type_real_get_parameters;
	((ValaDataTypeClass *) klass)->is_reference_type_or_type_parameter = (gboolean (*) (ValaDataType *)) vala_data_type_real_is_reference_type_or_type_parameter;
	((ValaDataTypeClass *) klass)->is_array = (gboolean (*) (ValaDataType *)) vala_data_type_real_is_array;
	((ValaDataTypeClass *) klass)->is_accessible = (gboolean (*) (ValaDataType *, ValaSymbol*)) vala_data_type_real_is_accessible;
	((ValaDataTypeClass *) klass)->get_member = (ValaSymbol* (*) (ValaDataType *, const gchar*)) vala_data_type_real_get_member;
	((ValaDataTypeClass *) klass)->get_pointer_member = (ValaSymbol* (*) (ValaDataType *, const gchar*)) vala_data_type_real_get_pointer_member;
	((ValaDataTypeClass *) klass)->is_real_struct_type = (gboolean (*) (ValaDataType *)) vala_data_type_real_is_real_struct_type;
	((ValaDataTypeClass *) klass)->is_disposable = (gboolean (*) (ValaDataType *)) vala_data_type_real_is_disposable;
	((ValaDataTypeClass *) klass)->get_actual_type = (ValaDataType* (*) (ValaDataType *, ValaDataType*, ValaList*, ValaCodeNode*)) vala_data_type_real_get_actual_type;
	((ValaDataTypeClass *) klass)->infer_type_argument = (ValaDataType* (*) (ValaDataType *, ValaTypeParameter*, ValaDataType*)) vala_data_type_real_infer_type_argument;
	((ValaDataTypeClass *) klass)->to_prototype_string = (gchar* (*) (ValaDataType *, const gchar*)) vala_data_type_real_to_prototype_string;
}


static void
vala_data_type_instance_init (ValaDataType * self)
{
	self->priv = vala_data_type_get_instance_private (self);
}


static void
vala_data_type_finalize (ValaCodeNode * obj)
{
	ValaDataType * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, VALA_TYPE_DATA_TYPE, ValaDataType);
	_vala_iterable_unref0 (self->priv->type_argument_list);
	VALA_CODE_NODE_CLASS (vala_data_type_parent_class)->finalize (obj);
}


/**
 * A reference to a data type. This is used to specify static types of
 * expressions.
 */
GType
vala_data_type_get_type (void)
{
	static volatile gsize vala_data_type_type_id__volatile = 0;
	if (g_once_init_enter (&vala_data_type_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ValaDataTypeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) vala_data_type_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ValaDataType), 0, (GInstanceInitFunc) vala_data_type_instance_init, NULL };
		GType vala_data_type_type_id;
		vala_data_type_type_id = g_type_register_static (VALA_TYPE_CODE_NODE, "ValaDataType", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
		ValaDataType_private_offset = g_type_add_instance_private (vala_data_type_type_id, sizeof (ValaDataTypePrivate));
		g_once_init_leave (&vala_data_type_type_id__volatile, vala_data_type_type_id);
	}
	return vala_data_type_type_id__volatile;
}



