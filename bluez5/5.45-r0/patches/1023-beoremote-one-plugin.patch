diff -Naur a/Makefile.plugins b/Makefile.plugins
--- a/Makefile.plugins	2019-03-08 06:16:44.051834802 +0000
+++ b/Makefile.plugins	2019-03-08 06:16:44.119835226 +0000
@@ -11,6 +11,12 @@
 builtin_modules += policy
 builtin_sources += plugins/policy.c
 
+builtin_modules += beoremote_one
+builtin_sources += plugins/beoremote_one.h \
+			plugins/beoremote_one.c \
+			plugins/beoremote_one_types.h \
+			plugins/beoremote_one_types.c
+
 if NFC
 builtin_modules += neard
 builtin_sources += plugins/neard.c
diff -Naur a/plugins/beoremote_one.c b/plugins/beoremote_one.c
--- a/plugins/beoremote_one.c	1970-01-01 00:00:00.000000000 +0000
+++ b/plugins/beoremote_one.c	2019-03-12 06:23:46.905426783 +0000
@@ -0,0 +1,621 @@
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <lib/bluetooth.h>
+#include <lib/uuid.h>
+#include <lib/bluetooth/sdp.h>
+#include <src/adapter.h>
+#include <src/device.h>
+#include <unistd.h>
+#include <src/plugin.h>
+#include <attrib/gatt-service.h>
+#include <attrib/att-database.h>
+#include <attrib/gattrib.h>
+#include <src/attrib-server.h>
+#include <attrib/att.h>
+#include <attrib/gatt.h>
+#include <src/log.h>
+
+#include "beoremote_one.h"
+
+int beoremote_one_socket = -1;
+GMutex beoremote_one_mutex;
+volatile gboolean beoremote_one_thread_stop = FALSE;
+GThread *beoremote_one_thread = NULL;
+bdaddr_t connected_device_address[BEOREMOTE_ONE_CONNECTED_MAX];
+beoremote_one_data_t beoremote_one_data[BEOREMOTE_ONE_ATTRIB_MAX];
+#ifdef BEOREMOTE_ONE_PLUGIN_TRACE
+int lock_count = 0;
+#endif
+
+typedef struct {
+    struct btd_adapter *adapter;
+    GSList *sdp_handles;
+    uint16_t value_handle[BEOREMOTE_ONE_ATTRIB_MAX];
+    uint16_t ccc_handle[BEOREMOTE_ONE_ATTRIB_MAX];
+} beoremote_one_adapter_t;
+
+static beoremote_one_adapter_t *beoremote_one_adapter = NULL;
+
+typedef struct {
+    enum beoremote_one_attrib attrib_type;
+    size_t size;
+} attrib_changed_payload_t;
+
+static int device_address_or_local_to_str(struct btd_device *device, char *str)
+{
+    const bdaddr_t *device_address = NULL;
+    int result;
+
+    if (device) {
+        device_address = device_get_address(device);
+    }
+    result = ba2str(device_address ? device_address : BDADDR_ANY, str);
+    if (result != BA_ADDRESS_STRING_BUFFER_SIZE - 1) {
+        error("Failed to convert addess to string, ba2str returned %d", result);
+    }
+    return result;
+}
+
+static gboolean do_attrib_changed(gpointer);
+static void do_data_free(attrib_changed_payload_t *);
+static void notify_attrib_change(enum beoremote_one_attrib, const uint8_t *, size_t);
+
+int attrib_changed(enum beoremote_one_attrib attrib_type, size_t size)
+{
+    attrib_changed_payload_t *data;
+
+#ifdef BEOREMOTE_ONE_PLUGIN_VERBOSE
+    DBG("(0x%04x)%s", beoremote_one_data[attrib_type].handle, beoremote_one_attrib_to_string(attrib_type));
+#endif
+    data = g_slice_new(attrib_changed_payload_t);
+    data->attrib_type = attrib_type;
+    data->size = size;
+
+#ifdef BEOREMOTE_ONE_PLUGIN_TRACE
+    DBG("g_slice_new %p", data);
+#endif
+    g_idle_add_full(G_PRIORITY_DEFAULT_IDLE, do_attrib_changed, (gpointer)data, (GDestroyNotify)do_data_free);
+
+    return 0;
+}
+
+static struct btd_adapter *get_adapter()
+{
+    if (beoremote_one_adapter) {
+        return beoremote_one_adapter->adapter;
+    }
+    return NULL;
+}
+
+static gboolean do_attrib_changed(gpointer data)
+{
+    attrib_changed_payload_t *payload = (attrib_changed_payload_t *)data;
+    struct btd_adapter *adapter;
+#ifdef BEOREMOTE_ONE_PLUGIN_VERBOSE
+    char string_buffer[ATTRIB_DATA_AS_STRING_BUFFER_SIZE];
+#endif
+
+    if (payload) {
+        aqquire_lock();
+
+        adapter = get_adapter();
+        if (adapter) {
+#ifdef BEOREMOTE_ONE_PLUGIN_VERBOSE
+            DBG("Update attribute (0x%04x)%s:[%s]",
+                beoremote_one_data[payload->attrib_type].handle,
+                beoremote_one_attrib_to_string(payload->attrib_type),
+                beoremote_one_attrib_data_to_string(
+                    payload->attrib_type,
+                    beoremote_one_data[payload->attrib_type].value,
+                    beoremote_one_attrib_size((enum beoremote_one_attrib)payload->attrib_type),
+                    &string_buffer,
+                    sizeof(string_buffer)));
+#endif
+            attrib_db_update(adapter, beoremote_one_data[payload->attrib_type].handle, NULL, beoremote_one_data[payload->attrib_type].value, payload->size, NULL);
+        }
+
+        if (payload->attrib_type == BEOREMOTE_ONE_ATTRIB_FEATURES_CHANGED) {
+#ifdef BEOREMOTE_ONE_PLUGIN_VERBOSE
+            DBG("notify_attrib_change for attribute %s", beoremote_one_attrib_to_string(payload->attrib_type));
+#endif
+            notify_attrib_change((enum beoremote_one_attrib)payload->attrib_type, beoremote_one_data[payload->attrib_type].value, payload->size);
+        }
+
+        release_lock();
+    }
+
+    return FALSE;
+}
+
+static void do_data_free(attrib_changed_payload_t *data)
+{
+#ifdef BEOREMOTE_ONE_PLUGIN_TRACE
+    DBG("g_slice_free %p", data);
+#endif
+    if (data) {
+        g_slice_free(attrib_changed_payload_t, data);
+    }
+}
+
+static void notify_attrib_change(enum beoremote_one_attrib attrib_type, const uint8_t *data, size_t size)
+{
+    int i, result;
+    struct btd_device *device;
+#ifdef BEOREMOTE_ONE_PLUGIN_VERBOSE
+    char device_address_str[BA_ADDRESS_STRING_BUFFER_SIZE] = { 0 };
+#endif
+
+    if (beoremote_one_adapter && beoremote_one_adapter->adapter) {
+        for (i = 0; i < BEOREMOTE_ONE_CONNECTED_MAX; i++) {
+            if (bacmp(&connected_device_address[i], BDADDR_ANY)) {
+#ifdef BEOREMOTE_ONE_PLUGIN_VERBOSE
+                ba2str(&connected_device_address[i], &device_address_str[0]);
+#endif
+                device = btd_adapter_find_device(beoremote_one_adapter->adapter, &connected_device_address[i], BDADDR_LE_PUBLIC);
+                if (device) {
+                    uint16_t handle = beoremote_one_adapter->value_handle[attrib_type];
+                    uint16_t ccc_handle = beoremote_one_adapter->ccc_handle[attrib_type];
+#ifdef BEOREMOTE_ONE_PLUGIN_VERBOSE
+                    DBG("attrib_notify to device %s for attribute %s(0x%04x,0x%04x)", device_address_str, beoremote_one_attrib_to_string(attrib_type), handle, ccc_handle);
+#endif
+                    result = attrib_notify(device, handle, ccc_handle, data, size, FALSE);
+                }
+
+                if (!device || result) {
+#ifdef BEOREMOTE_ONE_PLUGIN_VERBOSE
+                    DBG("Device with address %s not found. Clearing index %d", device_address_str, i);
+#endif
+                    bacpy(&connected_device_address[i], BDADDR_ANY);
+                }
+            }
+        }
+    }
+}
+
+void update_connected_device_address(struct btd_device *device)
+{
+    int i;
+    char device_address_str[BA_ADDRESS_STRING_BUFFER_SIZE] = { 0 };
+
+    for (i = 0; i < BEOREMOTE_ONE_CONNECTED_MAX; i++) {
+        if (bacmp(&connected_device_address[i], device_get_address(device)) == 0) {
+            break;
+        }
+    }
+
+    if (i == BEOREMOTE_ONE_CONNECTED_MAX) {
+        for (i = 0; i < BEOREMOTE_ONE_CONNECTED_MAX; i++) {
+            if (bacmp(&connected_device_address[i], BDADDR_ANY) == 0) {
+#ifdef BEOREMOTE_ONE_PLUGIN_VERBOSE
+                device_address_or_local_to_str(device, &device_address_str[0]);
+                DBG("Updating index %d with device address %s", i, device_address_str);
+#endif
+                bacpy(&connected_device_address[i], device_get_address(device));
+                break;
+            }
+        }
+
+        if (i == BEOREMOTE_ONE_CONNECTED_MAX) {
+            device_address_or_local_to_str(device, &device_address_str[0]);
+            warn("Failed to add device address %s. Too many remotes connected", device_address_str);
+        }
+    }
+}
+
+static gboolean beoremote_one_service_register(beoremote_one_adapter_t *adapter)
+{
+    gboolean gret;
+    bt_uuid_t uuid[BEOREMOTE_ONE_ATTRIB_MAX];
+    int attrib_type;
+
+    /* Create the different UUIDs based on the BeoRemote One GATT service specification */
+    bt_string_to_uuid(&uuid[0], "00000000-0000-1000-1000-00805F9B34FB");
+    bt_string_to_uuid(&uuid[BEOREMOTE_ONE_ATTRIB_VERSION], "00000001-0000-1000-1000-00805F9B34FB");
+    bt_string_to_uuid(&uuid[BEOREMOTE_ONE_ATTRIB_FEATURES], "00000002-0000-1000-1000-00805F9B34FB");
+    bt_string_to_uuid(&uuid[BEOREMOTE_ONE_ATTRIB_FEATURES_CHANGED], "00000003-0000-1000-1000-00805F9B34FB");
+    bt_string_to_uuid(&uuid[BEOREMOTE_ONE_ATTRIB_INJECT_PRESS], "00000004-0000-1000-1000-00805F9B34FB");
+    bt_string_to_uuid(&uuid[BEOREMOTE_ONE_ATTRIB_INJECT_RELEASE], "00000005-0000-1000-1000-00805F9B34FB");
+    bt_string_to_uuid(&uuid[BEOREMOTE_ONE_ATTRIB_DISC_TRACK], "00000006-0000-1000-1000-00805F9B34FB");
+    bt_string_to_uuid(&uuid[BEOREMOTE_ONE_ATTRIB_STAND_POSITIONS], "00000007-0000-1000-1000-00805F9B34FB");
+    bt_string_to_uuid(&uuid[BEOREMOTE_ONE_ATTRIB_ACTIVE_STAND_POSITION], "00000008-0000-1000-1000-00805F9B34FB");
+    bt_string_to_uuid(&uuid[BEOREMOTE_ONE_ATTRIB_SPEAKER_GROUPS], "0000000D-0000-1000-1000-00805F9B34FB");
+    bt_string_to_uuid(&uuid[BEOREMOTE_ONE_ATTRIB_ACTIVE_SPEAKER_GROUP], "0000000E-0000-1000-1000-00805F9B34FB");
+    bt_string_to_uuid(&uuid[BEOREMOTE_ONE_ATTRIB_SOUND_MODES], "0000000F-0000-1000-1000-00805F9B34FB");
+    bt_string_to_uuid(&uuid[BEOREMOTE_ONE_ATTRIB_ACTIVE_SOUND_MODE], "00000010-0000-1000-1000-00805F9B34FB");
+    bt_string_to_uuid(&uuid[BEOREMOTE_ONE_ATTRIB_PICTURE_FORMATS], "00000011-0000-1000-1000-00805F9B34FB");
+    bt_string_to_uuid(&uuid[BEOREMOTE_ONE_ATTRIB_ACTIVE_PICTURE_FORMAT], "00000012-0000-1000-1000-00805F9B34FB");
+    bt_string_to_uuid(&uuid[BEOREMOTE_ONE_ATTRIB_PICTURE_MODES], "00000013-0000-1000-1000-00805F9B34FB");
+    bt_string_to_uuid(&uuid[BEOREMOTE_ONE_ATTRIB_ACTIVE_PICTURE_MODE], "00000014-0000-1000-1000-00805F9B34FB");
+    bt_string_to_uuid(&uuid[BEOREMOTE_ONE_ATTRIB_PICTURE_MUTE], "00000015-0000-1000-1000-00805F9B34FB");
+    bt_string_to_uuid(&uuid[BEOREMOTE_ONE_ATTRIB_2D_3D_MODES], "00000016-0000-1000-1000-00805F9B34FB");
+    bt_string_to_uuid(&uuid[BEOREMOTE_ONE_ATTRIB_ACTIVE_2D_3D_MODE], "00000017-0000-1000-1000-00805F9B34FB");
+    bt_string_to_uuid(&uuid[BEOREMOTE_ONE_ATTRIB_TV_SOURCES], "00000018-0000-1000-1000-00805F9B34FB");
+    bt_string_to_uuid(&uuid[BEOREMOTE_ONE_ATTRIB_MUSIC_SOURCES], "00000019-0000-1000-1000-00805F9B34FB");
+    bt_string_to_uuid(&uuid[BEOREMOTE_ONE_ATTRIB_ACTIVE_SOURCE], "0000001A-0000-1000-1000-00805F9B34FB");
+    bt_string_to_uuid(&uuid[BEOREMOTE_ONE_ATTRIB_CUSTOM_COMMANDS], "0000001B-0000-1000-1000-00805F9B34FB");
+    bt_string_to_uuid(&uuid[BEOREMOTE_ONE_ATTRIB_ACTIVE_CUSTOM_COMMAND], "0000001C-0000-1000-1000-00805F9B34FB");
+    bt_string_to_uuid(&uuid[BEOREMOTE_ONE_ATTRIB_HOME_CONTROL_SCENES], "0000001D-0000-1000-1000-00805F9B34FB");
+    bt_string_to_uuid(&uuid[BEOREMOTE_ONE_ATTRIB_ACTIVE_HOME_CONTROL_SCENE], "0000001E-0000-1000-1000-00805F9B34FB");
+    bt_string_to_uuid(&uuid[BEOREMOTE_ONE_ATTRIB_CINEMA_MODE], "0000001F-0000-1000-1000-00805F9B34FB");
+    bt_string_to_uuid(&uuid[BEOREMOTE_ONE_ATTRIB_EXPERIENCES], "00000020-0000-1000-1000-00805F9B34FB");
+    bt_string_to_uuid(&uuid[BEOREMOTE_ONE_ATTRIB_ACTIVE_EXPERIENCE], "00000021-0000-1000-1000-00805F9B34FB");
+    bt_string_to_uuid(&uuid[BEOREMOTE_ONE_ATTRIB_CONTROL_1], "00000022-0000-1000-1000-00805F9B34FB");
+    bt_string_to_uuid(&uuid[BEOREMOTE_ONE_ATTRIB_CONTROL_2], "00000023-0000-1000-1000-00805F9B34FB");
+    bt_string_to_uuid(&uuid[BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_1], "00000024-0000-1000-1000-00805F9B34FB");
+    bt_string_to_uuid(&uuid[BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_2], "00000025-0000-1000-1000-00805F9B34FB");
+    bt_string_to_uuid(&uuid[BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_3], "00000026-0000-1000-1000-00805F9B34FB");
+    bt_string_to_uuid(&uuid[BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_4], "00000027-0000-1000-1000-00805F9B34FB");
+    bt_string_to_uuid(&uuid[BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_5], "00000028-0000-1000-1000-00805F9B34FB");
+    bt_string_to_uuid(&uuid[BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_6], "00000029-0000-1000-1000-00805F9B34FB");
+    bt_string_to_uuid(&uuid[BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_7], "0000002A-0000-1000-1000-00805F9B34FB");
+    bt_string_to_uuid(&uuid[BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_8], "0000002B-0000-1000-1000-00805F9B34FB");
+    bt_string_to_uuid(&uuid[BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_9], "0000002C-0000-1000-1000-00805F9B34FB");
+    bt_string_to_uuid(&uuid[BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_10], "0000002D-0000-1000-1000-00805F9B34FB");
+    bt_string_to_uuid(&uuid[BEOREMOTE_ONE_ATTRIB_ACTIVE_SOURCE_CONTENT], "0000002E-0000-1000-1000-00805F9B34FB");
+    bt_string_to_uuid(&uuid[BEOREMOTE_ONE_ATTRIB_MY_BUTTONS], "0000002F-0000-1000-1000-00805F9B34FB");
+
+    /* IMPORTANT: When adding new characterists to the service below they MUST be added to the top of the list
+     * This is so the exists characteristics does not get a new handle (which bluez assigsn from the bottom up).
+     * BeoRemoteOne is caching the handles, so changing them will break the functionality
+     */
+    gret = gatt_service_add(beoremote_one_adapter->adapter,
+        /* Service UUID */
+        GATT_PRIM_SVC_UUID, &uuid[0],
+
+        /* Home control scenes characteristic */
+        GATT_OPT_CHR_UUID, &uuid[BEOREMOTE_ONE_ATTRIB_HOME_CONTROL_SCENES],
+        GATT_OPT_CHR_PROPS, GATT_CHR_PROP_READ,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_READ, beoremote_one_attrib_read, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_GET_HANDLE, &beoremote_one_adapter->value_handle[BEOREMOTE_ONE_ATTRIB_HOME_CONTROL_SCENES],
+
+        /* Active home control scene characteristic */
+        GATT_OPT_CHR_UUID, &uuid[BEOREMOTE_ONE_ATTRIB_ACTIVE_HOME_CONTROL_SCENE],
+        GATT_OPT_CHR_PROPS, GATT_CHR_PROP_READ | GATT_CHR_PROP_WRITE,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_READ, beoremote_one_attrib_read, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_WRITE, beoremote_one_attrib_write, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_GET_HANDLE, &beoremote_one_adapter->value_handle[BEOREMOTE_ONE_ATTRIB_ACTIVE_HOME_CONTROL_SCENE],
+
+        /* Cinema mode characteristic */
+        GATT_OPT_CHR_UUID, &uuid[BEOREMOTE_ONE_ATTRIB_CINEMA_MODE],
+        GATT_OPT_CHR_PROPS, GATT_CHR_PROP_READ | GATT_CHR_PROP_WRITE,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_READ, beoremote_one_attrib_read, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_WRITE, beoremote_one_attrib_write, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_GET_HANDLE, &beoremote_one_adapter->value_handle[BEOREMOTE_ONE_ATTRIB_CINEMA_MODE],
+
+        /* Experiences characteristic */
+        GATT_OPT_CHR_UUID, &uuid[BEOREMOTE_ONE_ATTRIB_EXPERIENCES],
+        GATT_OPT_CHR_PROPS, GATT_CHR_PROP_READ,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_READ, beoremote_one_attrib_read, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_GET_HANDLE, &beoremote_one_adapter->value_handle[BEOREMOTE_ONE_ATTRIB_EXPERIENCES],
+
+        /* Active experience characteristic */
+        GATT_OPT_CHR_UUID, &uuid[BEOREMOTE_ONE_ATTRIB_ACTIVE_EXPERIENCE],
+        GATT_OPT_CHR_PROPS, GATT_CHR_PROP_READ | GATT_CHR_PROP_WRITE,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_READ, beoremote_one_attrib_read, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_WRITE, beoremote_one_attrib_write, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_GET_HANDLE, &beoremote_one_adapter->value_handle[BEOREMOTE_ONE_ATTRIB_ACTIVE_EXPERIENCE],
+
+        /* Control 1 characteristic */
+        GATT_OPT_CHR_UUID, &uuid[BEOREMOTE_ONE_ATTRIB_CONTROL_1],
+        GATT_OPT_CHR_PROPS, GATT_CHR_PROP_READ | GATT_CHR_PROP_WRITE,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_READ, beoremote_one_attrib_read, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_WRITE, beoremote_one_attrib_write, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_GET_HANDLE, &beoremote_one_adapter->value_handle[BEOREMOTE_ONE_ATTRIB_CONTROL_1],
+
+        /* Control 2 characteristic */
+        GATT_OPT_CHR_UUID, &uuid[BEOREMOTE_ONE_ATTRIB_CONTROL_2],
+        GATT_OPT_CHR_PROPS, GATT_CHR_PROP_READ | GATT_CHR_PROP_WRITE,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_READ, beoremote_one_attrib_read, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_WRITE, beoremote_one_attrib_write, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_GET_HANDLE, &beoremote_one_adapter->value_handle[BEOREMOTE_ONE_ATTRIB_CONTROL_2],
+
+        /* Source content 1 characteristic */
+        GATT_OPT_CHR_UUID, &uuid[BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_1],
+        GATT_OPT_CHR_PROPS, GATT_CHR_PROP_READ,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_READ, beoremote_one_attrib_read, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_GET_HANDLE, &beoremote_one_adapter->value_handle[BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_1],
+
+        /* Source content 2 characteristic */
+        GATT_OPT_CHR_UUID, &uuid[BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_2],
+        GATT_OPT_CHR_PROPS, GATT_CHR_PROP_READ,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_READ, beoremote_one_attrib_read, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_GET_HANDLE, &beoremote_one_adapter->value_handle[BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_2],
+
+        /* Source content 3 characteristic */
+        GATT_OPT_CHR_UUID, &uuid[BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_3],
+        GATT_OPT_CHR_PROPS, GATT_CHR_PROP_READ,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_READ, beoremote_one_attrib_read, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_GET_HANDLE, &beoremote_one_adapter->value_handle[BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_3],
+
+        /* Source content 4 characteristic */
+        GATT_OPT_CHR_UUID, &uuid[BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_4],
+        GATT_OPT_CHR_PROPS, GATT_CHR_PROP_READ,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_READ, beoremote_one_attrib_read, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_GET_HANDLE, &beoremote_one_adapter->value_handle[BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_4],
+
+        /* Source content 5 characteristic */
+        GATT_OPT_CHR_UUID, &uuid[BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_5],
+        GATT_OPT_CHR_PROPS, GATT_CHR_PROP_READ,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_READ, beoremote_one_attrib_read, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_GET_HANDLE, &beoremote_one_adapter->value_handle[BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_5],
+
+        /* Source content 6 characteristic */
+        GATT_OPT_CHR_UUID, &uuid[BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_6],
+        GATT_OPT_CHR_PROPS, GATT_CHR_PROP_READ,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_READ, beoremote_one_attrib_read, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_GET_HANDLE, &beoremote_one_adapter->value_handle[BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_6],
+
+        /* Source content 7 characteristic */
+        GATT_OPT_CHR_UUID, &uuid[BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_7],
+        GATT_OPT_CHR_PROPS, GATT_CHR_PROP_READ,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_READ, beoremote_one_attrib_read, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_GET_HANDLE, &beoremote_one_adapter->value_handle[BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_7],
+
+        /* Source content 8 characteristic */
+        GATT_OPT_CHR_UUID, &uuid[BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_8],
+        GATT_OPT_CHR_PROPS, GATT_CHR_PROP_READ,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_READ, beoremote_one_attrib_read, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_GET_HANDLE, &beoremote_one_adapter->value_handle[BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_8],
+
+        /* Source content 9 characteristic */
+        GATT_OPT_CHR_UUID, &uuid[BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_9],
+        GATT_OPT_CHR_PROPS, GATT_CHR_PROP_READ,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_READ, beoremote_one_attrib_read, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_GET_HANDLE, &beoremote_one_adapter->value_handle[BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_9],
+
+        /* Source content 10 characteristic */
+        GATT_OPT_CHR_UUID, &uuid[BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_10],
+        GATT_OPT_CHR_PROPS, GATT_CHR_PROP_READ,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_READ, beoremote_one_attrib_read, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_GET_HANDLE, &beoremote_one_adapter->value_handle[BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_10],
+
+        /* Active source content 1-10 characteristics */
+        GATT_OPT_CHR_UUID, &uuid[BEOREMOTE_ONE_ATTRIB_ACTIVE_SOURCE_CONTENT],
+        GATT_OPT_CHR_PROPS, GATT_CHR_PROP_READ | GATT_CHR_PROP_WRITE,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_READ, beoremote_one_attrib_read, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_WRITE, beoremote_one_attrib_write, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_GET_HANDLE, &beoremote_one_adapter->value_handle[BEOREMOTE_ONE_ATTRIB_ACTIVE_SOURCE_CONTENT],
+
+        /* Version characteristic */
+        GATT_OPT_CHR_UUID, &uuid[BEOREMOTE_ONE_ATTRIB_VERSION],
+        GATT_OPT_CHR_PROPS, GATT_CHR_PROP_READ,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_READ, beoremote_one_attrib_read, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_GET_HANDLE, &beoremote_one_adapter->value_handle[BEOREMOTE_ONE_ATTRIB_VERSION],
+
+        /* Features characteristic */
+        GATT_OPT_CHR_UUID, &uuid[BEOREMOTE_ONE_ATTRIB_FEATURES],
+        GATT_OPT_CHR_PROPS, GATT_CHR_PROP_READ,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_READ, beoremote_one_attrib_read, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_GET_HANDLE, &beoremote_one_adapter->value_handle[BEOREMOTE_ONE_ATTRIB_FEATURES],
+
+        /* Features changed characteristic */
+        GATT_OPT_CHR_UUID, &uuid[BEOREMOTE_ONE_ATTRIB_FEATURES_CHANGED],
+        GATT_OPT_CHR_PROPS, GATT_CHR_PROP_READ | GATT_CHR_PROP_INDICATE,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_READ, beoremote_one_attrib_read, beoremote_one_adapter->adapter,
+        GATT_OPT_CCC_GET_HANDLE, &beoremote_one_adapter->ccc_handle[BEOREMOTE_ONE_ATTRIB_FEATURES_CHANGED],
+        GATT_OPT_CHR_VALUE_GET_HANDLE, &beoremote_one_adapter->value_handle[BEOREMOTE_ONE_ATTRIB_FEATURES_CHANGED],
+
+        /* Inject press characteristic */
+        GATT_OPT_CHR_UUID, &uuid[BEOREMOTE_ONE_ATTRIB_INJECT_PRESS],
+        GATT_OPT_CHR_PROPS, GATT_CHR_PROP_WRITE,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_WRITE, beoremote_one_attrib_write, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_GET_HANDLE, &beoremote_one_adapter->value_handle[BEOREMOTE_ONE_ATTRIB_INJECT_PRESS],
+
+        /* Inject release characteristic */
+        GATT_OPT_CHR_UUID, &uuid[BEOREMOTE_ONE_ATTRIB_INJECT_RELEASE],
+        GATT_OPT_CHR_PROPS, GATT_CHR_PROP_WRITE,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_WRITE, beoremote_one_attrib_write, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_GET_HANDLE, &beoremote_one_adapter->value_handle[BEOREMOTE_ONE_ATTRIB_INJECT_RELEASE],
+
+        /* Disc track characteristic */
+        GATT_OPT_CHR_UUID, &uuid[BEOREMOTE_ONE_ATTRIB_DISC_TRACK],
+        GATT_OPT_CHR_PROPS, GATT_CHR_PROP_READ | GATT_CHR_PROP_WRITE,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_READ, beoremote_one_attrib_read, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_WRITE, beoremote_one_attrib_write, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_GET_HANDLE, &beoremote_one_adapter->value_handle[BEOREMOTE_ONE_ATTRIB_DISC_TRACK],
+
+        /* Stand positions characteristic */
+        GATT_OPT_CHR_UUID, &uuid[BEOREMOTE_ONE_ATTRIB_STAND_POSITIONS],
+        GATT_OPT_CHR_PROPS, GATT_CHR_PROP_READ,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_READ, beoremote_one_attrib_read, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_GET_HANDLE, &beoremote_one_adapter->value_handle[BEOREMOTE_ONE_ATTRIB_STAND_POSITIONS],
+
+        /* Active stand position characteristic */
+        GATT_OPT_CHR_UUID, &uuid[BEOREMOTE_ONE_ATTRIB_ACTIVE_STAND_POSITION],
+        GATT_OPT_CHR_PROPS, GATT_CHR_PROP_READ | GATT_CHR_PROP_WRITE,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_READ, beoremote_one_attrib_read, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_WRITE, beoremote_one_attrib_write, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_GET_HANDLE, &beoremote_one_adapter->value_handle[BEOREMOTE_ONE_ATTRIB_ACTIVE_STAND_POSITION],
+
+        /* Speaker groups characteristic */
+        GATT_OPT_CHR_UUID, &uuid[BEOREMOTE_ONE_ATTRIB_SPEAKER_GROUPS],
+        GATT_OPT_CHR_PROPS, GATT_CHR_PROP_READ,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_READ, beoremote_one_attrib_read, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_GET_HANDLE, &beoremote_one_adapter->value_handle[BEOREMOTE_ONE_ATTRIB_SPEAKER_GROUPS],
+
+        /* Active speaker group characteristic */
+        GATT_OPT_CHR_UUID, &uuid[BEOREMOTE_ONE_ATTRIB_ACTIVE_SPEAKER_GROUP],
+        GATT_OPT_CHR_PROPS, GATT_CHR_PROP_READ | GATT_CHR_PROP_WRITE,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_READ, beoremote_one_attrib_read, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_WRITE, beoremote_one_attrib_write, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_GET_HANDLE, &beoremote_one_adapter->value_handle[BEOREMOTE_ONE_ATTRIB_ACTIVE_SPEAKER_GROUP],
+
+        /* Sound modes characteristic */
+        GATT_OPT_CHR_UUID, &uuid[BEOREMOTE_ONE_ATTRIB_SOUND_MODES],
+        GATT_OPT_CHR_PROPS, GATT_CHR_PROP_READ,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_READ, beoremote_one_attrib_read, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_GET_HANDLE, &beoremote_one_adapter->value_handle[BEOREMOTE_ONE_ATTRIB_SOUND_MODES],
+
+        /* Active sound mode characteristic */
+        GATT_OPT_CHR_UUID, &uuid[BEOREMOTE_ONE_ATTRIB_ACTIVE_SOUND_MODE],
+        GATT_OPT_CHR_PROPS, GATT_CHR_PROP_READ | GATT_CHR_PROP_WRITE,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_READ, beoremote_one_attrib_read, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_WRITE, beoremote_one_attrib_write, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_GET_HANDLE, &beoremote_one_adapter->value_handle[BEOREMOTE_ONE_ATTRIB_ACTIVE_SOUND_MODE],
+
+        /* Picture formats characteristic */
+        GATT_OPT_CHR_UUID, &uuid[BEOREMOTE_ONE_ATTRIB_PICTURE_FORMATS],
+        GATT_OPT_CHR_PROPS, GATT_CHR_PROP_READ,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_READ, beoremote_one_attrib_read, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_GET_HANDLE, &beoremote_one_adapter->value_handle[BEOREMOTE_ONE_ATTRIB_PICTURE_FORMATS],
+
+        /* Active picture format characteristic */
+        GATT_OPT_CHR_UUID, &uuid[BEOREMOTE_ONE_ATTRIB_ACTIVE_PICTURE_FORMAT],
+        GATT_OPT_CHR_PROPS, GATT_CHR_PROP_READ | GATT_CHR_PROP_WRITE,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_READ, beoremote_one_attrib_read, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_WRITE, beoremote_one_attrib_write, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_GET_HANDLE, &beoremote_one_adapter->value_handle[BEOREMOTE_ONE_ATTRIB_ACTIVE_PICTURE_FORMAT],
+
+        /* Picture modes characteristic */
+        GATT_OPT_CHR_UUID, &uuid[BEOREMOTE_ONE_ATTRIB_PICTURE_MODES],
+        GATT_OPT_CHR_PROPS, GATT_CHR_PROP_READ,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_READ, beoremote_one_attrib_read, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_GET_HANDLE, &beoremote_one_adapter->value_handle[BEOREMOTE_ONE_ATTRIB_PICTURE_MODES],
+
+        /* Active picture mode characteristic */
+        GATT_OPT_CHR_UUID, &uuid[BEOREMOTE_ONE_ATTRIB_ACTIVE_PICTURE_MODE],
+        GATT_OPT_CHR_PROPS, GATT_CHR_PROP_READ | GATT_CHR_PROP_WRITE,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_READ, beoremote_one_attrib_read, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_WRITE, beoremote_one_attrib_write, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_GET_HANDLE, &beoremote_one_adapter->value_handle[BEOREMOTE_ONE_ATTRIB_ACTIVE_PICTURE_MODE],
+
+        /* Picture mute characteristic */
+        GATT_OPT_CHR_UUID, &uuid[BEOREMOTE_ONE_ATTRIB_PICTURE_MUTE],
+        GATT_OPT_CHR_PROPS, GATT_CHR_PROP_READ | GATT_CHR_PROP_WRITE,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_READ, beoremote_one_attrib_read, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_WRITE, beoremote_one_attrib_write, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_GET_HANDLE, &beoremote_one_adapter->value_handle[BEOREMOTE_ONE_ATTRIB_PICTURE_MUTE],
+
+        /* 2D/3D modes characteristic */
+        GATT_OPT_CHR_UUID, &uuid[BEOREMOTE_ONE_ATTRIB_2D_3D_MODES],
+        GATT_OPT_CHR_PROPS, GATT_CHR_PROP_READ,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_READ, beoremote_one_attrib_read, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_GET_HANDLE, &beoremote_one_adapter->value_handle[BEOREMOTE_ONE_ATTRIB_2D_3D_MODES],
+
+        /* Active 2D/3D mode characteristic */
+        GATT_OPT_CHR_UUID, &uuid[BEOREMOTE_ONE_ATTRIB_ACTIVE_2D_3D_MODE],
+        GATT_OPT_CHR_PROPS, GATT_CHR_PROP_READ | GATT_CHR_PROP_WRITE,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_READ, beoremote_one_attrib_read, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_WRITE, beoremote_one_attrib_write, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_GET_HANDLE, &beoremote_one_adapter->value_handle[BEOREMOTE_ONE_ATTRIB_ACTIVE_2D_3D_MODE],
+
+        /* TV sources characteristic */
+        GATT_OPT_CHR_UUID, &uuid[BEOREMOTE_ONE_ATTRIB_TV_SOURCES],
+        GATT_OPT_CHR_PROPS, GATT_CHR_PROP_READ,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_READ, beoremote_one_attrib_read, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_GET_HANDLE, &beoremote_one_adapter->value_handle[BEOREMOTE_ONE_ATTRIB_TV_SOURCES],
+
+        /* Music sources characteristic */
+        GATT_OPT_CHR_UUID, &uuid[BEOREMOTE_ONE_ATTRIB_MUSIC_SOURCES],
+        GATT_OPT_CHR_PROPS, GATT_CHR_PROP_READ,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_READ, beoremote_one_attrib_read, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_GET_HANDLE, &beoremote_one_adapter->value_handle[BEOREMOTE_ONE_ATTRIB_MUSIC_SOURCES],
+
+        /* Active source characteristic */
+        GATT_OPT_CHR_UUID, &uuid[BEOREMOTE_ONE_ATTRIB_ACTIVE_SOURCE],
+        GATT_OPT_CHR_PROPS, GATT_CHR_PROP_READ | GATT_CHR_PROP_WRITE,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_READ, beoremote_one_attrib_read, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_WRITE, beoremote_one_attrib_write, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_GET_HANDLE, &beoremote_one_adapter->value_handle[BEOREMOTE_ONE_ATTRIB_ACTIVE_SOURCE],
+
+        /* Custom commands characteristic */
+        GATT_OPT_CHR_UUID, &uuid[BEOREMOTE_ONE_ATTRIB_CUSTOM_COMMANDS],
+        GATT_OPT_CHR_PROPS, GATT_CHR_PROP_READ,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_READ, beoremote_one_attrib_read, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_GET_HANDLE, &beoremote_one_adapter->value_handle[BEOREMOTE_ONE_ATTRIB_CUSTOM_COMMANDS],
+
+        /* Active custom command characteristic */
+        GATT_OPT_CHR_UUID, &uuid[BEOREMOTE_ONE_ATTRIB_ACTIVE_CUSTOM_COMMAND],
+        GATT_OPT_CHR_PROPS, GATT_CHR_PROP_READ | GATT_CHR_PROP_WRITE,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_READ, beoremote_one_attrib_read, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_WRITE, beoremote_one_attrib_write, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_GET_HANDLE, &beoremote_one_adapter->value_handle[BEOREMOTE_ONE_ATTRIB_ACTIVE_CUSTOM_COMMAND],
+
+        /* My buttons characteristic */
+        GATT_OPT_CHR_UUID, &uuid[BEOREMOTE_ONE_ATTRIB_MY_BUTTONS],
+        GATT_OPT_CHR_PROPS, GATT_CHR_PROP_READ,
+        GATT_OPT_CHR_VALUE_CB, ATTRIB_READ, beoremote_one_attrib_read, beoremote_one_adapter->adapter,
+        GATT_OPT_CHR_VALUE_GET_HANDLE, &beoremote_one_adapter->value_handle[BEOREMOTE_ONE_ATTRIB_MY_BUTTONS],
+
+        GATT_OPT_INVALID);
+
+    if (gret) {
+        for (attrib_type = 0; attrib_type < BEOREMOTE_ONE_ATTRIB_MAX; attrib_type++) {
+            beoremote_one_data[attrib_type].handle = beoremote_one_adapter->value_handle[attrib_type];
+        }
+
+        /* Update version attribute */
+        aqquire_lock();
+        static const char *ATTRIB_VERSION = "1.0";
+        memcpy(beoremote_one_data[BEOREMOTE_ONE_ATTRIB_VERSION].value, ATTRIB_VERSION, strlen(ATTRIB_VERSION));
+        release_lock();
+        attrib_changed(BEOREMOTE_ONE_ATTRIB_VERSION, strlen(ATTRIB_VERSION));
+    }
+
+    return gret;
+}
+
+static void beoremote_one_adapter_remove(struct btd_adapter *adapter)
+{
+    if (beoremote_one_adapter) {
+        while (beoremote_one_adapter->sdp_handles) {
+            uint32_t handle = GPOINTER_TO_UINT(beoremote_one_adapter->sdp_handles->data);
+
+            attrib_free_sdp(adapter, handle);
+            beoremote_one_adapter->sdp_handles = g_slist_remove(beoremote_one_adapter->sdp_handles,
+                beoremote_one_adapter->sdp_handles->data);
+        }
+
+        if (beoremote_one_adapter->adapter)
+            btd_adapter_unref(beoremote_one_adapter->adapter);
+
+        g_free(beoremote_one_adapter);
+        beoremote_one_adapter = NULL;
+    }
+}
+
+static int beoremote_one_adapter_probe(struct btd_adapter *adapter)
+{
+    if (beoremote_one_adapter == NULL) {
+        beoremote_one_adapter = g_new0(beoremote_one_adapter_t, 1);
+        beoremote_one_adapter->adapter = btd_adapter_ref(adapter);
+
+        if (!beoremote_one_service_register(beoremote_one_adapter)) {
+            beoremote_one_adapter_remove(beoremote_one_adapter->adapter);
+            error("Failed to register BeoRemote One service");
+            return -EIO;
+        }
+    }
+
+    DBG("BeoRemote One service registered");
+
+    return 0;
+}
+
+static struct btd_adapter_driver beoremote_one_adapter_driver = {
+    .name = "beoremote_one_adapter_driver",
+    .probe = beoremote_one_adapter_probe,
+    .remove = beoremote_one_adapter_remove,
+};
+
+static int do_beoremote_one_init(void)
+{
+    int i;
+
+    for (i = 0; i < BEOREMOTE_ONE_CONNECTED_MAX; i++) {
+        bacpy(&connected_device_address[i], BDADDR_ANY);
+    }
+
+    beoremote_one_init();
+    return btd_register_adapter_driver(&beoremote_one_adapter_driver);
+}
+
+static void do_beoremote_one_exit(void)
+{
+    beoremote_one_exit();
+    btd_unregister_adapter_driver(&beoremote_one_adapter_driver);
+}
+
+BLUETOOTH_PLUGIN_DEFINE(beoremote_one, VERSION, BLUETOOTH_PLUGIN_PRIORITY_DEFAULT, do_beoremote_one_init, do_beoremote_one_exit)
diff -Naur a/plugins/beoremote_one.h b/plugins/beoremote_one.h
--- a/plugins/beoremote_one.h	1970-01-01 00:00:00.000000000 +0000
+++ b/plugins/beoremote_one.h	2019-03-12 09:05:59.735752203 +0000
@@ -0,0 +1,415 @@
+#ifndef BEOREMOTE_ONE_H
+#define BEOREMOTE_ONE_H
+
+#include <glib.h>
+#include <errno.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/un.h>
+#include <sys/socket.h>
+#ifdef BUILDTYPE_PC
+#include <boost/thread.hpp>
+#endif
+
+#include "beoremote_one_types.h"
+
+#ifndef BUILDTYPE_PC
+#define BEOREMOTE_ONE_PLUGIN_VERBOSE
+#endif
+
+typedef struct {
+    uint16_t handle;
+    uint8_t value[BEOREMOTE_ONE_ATTRIB_MAX_SIZE];
+} beoremote_one_data_t;
+
+extern int beoremote_one_socket;
+extern GMutex beoremote_one_mutex;
+extern volatile gboolean beoremote_one_thread_stop;
+extern GThread *beoremote_one_thread;
+#ifdef BUILDTYPE_PC // Only used for testing,
+extern volatile gboolean socket_created_test;
+extern GCond beoremote_one_attrib_updated_condition;
+// Will be set to TRUE when the socket server has accepted
+// an incoming connection.
+extern volatile gboolean beoremote_one_thread_accepted_connection;
+extern char beoremote_one_socket_path[256];
+#endif
+extern beoremote_one_data_t beoremote_one_data[];
+
+#ifdef BEOREMOTE_ONE_PLUGIN_TRACE
+extern int lock_count;
+#endif
+
+#ifdef BEOREMOTE_ONE_PLUGIN_VERBOSE
+#define ATTRIB_DATA_AS_STRING_BUFFER_SIZE 1024
+#endif
+
+int attrib_changed(enum beoremote_one_attrib, size_t);
+
+#define BA_ADDRESS_STRING_BUFFER_SIZE 18 // Buffer size of MAC address string 11:22:33:44:55:66
+static int device_address_or_local_to_str(struct btd_device *, char *);
+
+void update_connected_device_address(struct btd_device *);
+
+static int beoremote_one_socket_create(char *path)
+{
+    int sock, ret;
+    struct sockaddr_un addr;
+
+    if ((sock = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {
+        int err = errno;
+        error("%s: Socket error(%d): \"%s\"\n", __func__, err, strerror(err));
+        return sock;
+    }
+
+    addr.sun_family = AF_UNIX;
+    strncpy(addr.sun_path, path, sizeof(addr.sun_path) - 1);
+
+    if (unlink(path) < 0) {
+        int err = errno;
+        if (err != ENOENT) {
+            error("%s: Unlink error(%d): \"%s\"\n", __func__, err, strerror(err));
+        }
+    }
+
+    if ((ret = bind(sock, (struct sockaddr *)&addr, sizeof(addr))) < 0) {
+        int err = errno;
+        error("%s: Bind error(%d): \"%s\"\n", __func__, err, strerror(err));
+        return ret;
+    }
+
+    if ((ret = listen(sock, 1)) < 0) {
+        int err = errno;
+        error("%s: Listen error(%d): \"%s\"\n", __func__, err, strerror(err));
+        return ret;
+    }
+
+    return sock;
+}
+
+static int beoremote_one_socket_write(const uint8_t *data, uint16_t size)
+{
+    int bytes = -1;
+
+    if (beoremote_one_socket > 0) {
+        const uint8_t *data_end = data + size;
+        while (data < data_end) {
+            bytes = write(beoremote_one_socket, data, (data_end - data));
+            if (bytes < 0) {
+                int err = errno;
+                error("%s: Write error(%d): \"%s\"\n", __func__, err, strerror(err));
+                return bytes;
+            }
+            data += bytes;
+        }
+    }
+
+    return bytes;
+}
+
+static void aqquire_lock()
+{
+#ifdef BEOREMOTE_ONE_PLUGIN_TRACE
+    lock_count++;
+    DBG("-> %p %d", g_thread_self(), lock_count);
+#endif
+    g_mutex_lock(&beoremote_one_mutex);
+}
+
+static void release_lock()
+{
+    g_mutex_unlock(&beoremote_one_mutex);
+#ifdef BEOREMOTE_ONE_PLUGIN_TRACE
+    lock_count--;
+    DBG("<- %p %d", g_thread_self(), lock_count);
+#endif
+}
+
+static int beoremote_one_socket_recv(int socket, void *buffer, size_t size)
+{
+    int bytes = recv(socket, buffer, size, 0);
+    if (bytes == 0) {
+#ifdef BEOREMOTE_ONE_PLUGIN_TRACE
+        DBG("Socket(=%d) disconnected", socket);
+#endif
+        return -1;
+    } else if (bytes < 0) {
+        int err = errno;
+        switch (err) {
+        case EWOULDBLOCK:
+            return 0;
+        default:
+            error("%s: Failed to read message from socket(=%d), error [%s(%d)]\n", __func__, socket, strerror(err), err);
+            return -1;
+        }
+    }
+    return bytes;
+}
+
+static int beoremote_one_socket_read(int sock)
+{
+    int bytes = -1;
+    gboolean valid_msg_type;
+    static uint8_t msg_type, data[BEOREMOTE_ONE_ATTRIB_MAX_SIZE + BEOREMOTE_ONE_SOCKET_MSG_HEADER_SIZE];
+    static uint16_t msg_bytes = 0, data_bytes = 0, remaining_msg_bytes = 0;
+
+#ifdef BEOREMOTE_ONE_PLUGIN_TRACE
+    DBG("-> %p", g_thread_self());
+#endif
+
+    while (data_bytes < BEOREMOTE_ONE_SOCKET_MSG_HEADER_SIZE) {
+        bytes = beoremote_one_socket_recv(sock, &data[data_bytes], BEOREMOTE_ONE_SOCKET_MSG_HEADER_SIZE - data_bytes);
+        if (bytes < 0 || g_atomic_int_get(&beoremote_one_thread_stop)) {
+            msg_bytes = data_bytes = 0;
+            return -1;
+        }
+        data_bytes += bytes;
+    }
+
+    msg_type = data[0];
+    msg_bytes = ntohs(data[1] | (data[2] << 8));
+    valid_msg_type = msg_type > 0 && msg_type < BEOREMOTE_ONE_ATTRIB_MAX ? TRUE : FALSE;
+
+    if (valid_msg_type) {
+#ifdef BEOREMOTE_ONE_PLUGIN_VERBOSE
+        DBG("Received new value for attribute (0x%04x)%s with length %d", beoremote_one_data[msg_type].handle, beoremote_one_attrib_to_string((enum beoremote_one_attrib)msg_type), msg_bytes);
+#endif
+    } else {
+        warn("Invalid msg_type %d, msg_bytes %d", msg_type, msg_bytes);
+    }
+    if (msg_bytes > BEOREMOTE_ONE_ATTRIB_MAX_SIZE) {
+        msg_bytes = BEOREMOTE_ONE_ATTRIB_MAX_SIZE;
+    }
+
+    remaining_msg_bytes = msg_bytes;
+    while (data_bytes != (BEOREMOTE_ONE_SOCKET_MSG_HEADER_SIZE + msg_bytes)) {
+        bytes = beoremote_one_socket_recv(sock, &data[data_bytes], remaining_msg_bytes);
+        if (bytes < 0 || g_atomic_int_get(&beoremote_one_thread_stop)) {
+            msg_bytes = data_bytes = 0;
+            return -1;
+        }
+        data_bytes += bytes;
+        remaining_msg_bytes -= bytes;
+    }
+
+    if (valid_msg_type) {
+        aqquire_lock();
+        memcpy(beoremote_one_data[msg_type].value, &data[BEOREMOTE_ONE_SOCKET_MSG_HEADER_SIZE], msg_bytes);
+        if (beoremote_one_attrib_size((enum beoremote_one_attrib)msg_type) == BEOREMOTE_ONE_ATTRIB_MAX_SIZE)
+            beoremote_one_data[msg_type].value[msg_bytes < BEOREMOTE_ONE_ATTRIB_MAX_SIZE ? msg_bytes : BEOREMOTE_ONE_ATTRIB_MAX_SIZE - 1] = '\0';
+
+#ifdef BEOREMOTE_ONE_PLUGIN_TRACE
+        char string_buffer[msg_bytes + 1];
+        DBG("New content of attribute (0x%04x)%s is [%s]",
+            beoremote_one_data[msg_type].handle,
+            beoremote_one_attrib_to_string((enum beoremote_one_attrib)msg_type),
+            beoremote_one_attrib_data_to_string(
+                (enum beoremote_one_attrib)msg_type,
+                beoremote_one_data[msg_type].value,
+                msg_bytes,
+                &string_buffer,
+                sizeof(string_buffer)));
+#endif
+        release_lock();
+        attrib_changed((enum beoremote_one_attrib)msg_type, msg_bytes);
+
+#ifdef BUILDTYPE_PC
+        g_cond_signal(&beoremote_one_attrib_updated_condition);
+#endif
+    }
+
+    msg_bytes = data_bytes = 0;
+
+#ifdef BEOREMOTE_ONE_PLUGIN_TRACE
+    DBG("<- %p (bytes=%d)", g_thread_self(), bytes);
+#endif
+    return bytes;
+}
+
+static gpointer beoremote_one_socket_thread(gpointer data)
+{
+    (void)data;
+    fd_set active_fd_set;
+    fd_set read_fd_set;
+    struct timeval timeout;
+    int i;
+#ifndef BUILDTYPE_PC
+    int sock = beoremote_one_socket_create(BEOREMOTE_ONE_SOCKET_PATH);
+#else
+    int sock = beoremote_one_socket_create(beoremote_one_socket_path);
+    g_atomic_int_set(&socket_created_test, TRUE);
+#endif
+
+    FD_ZERO(&active_fd_set);
+    FD_SET(sock, &active_fd_set);
+
+    while (!g_atomic_int_get(&beoremote_one_thread_stop)) {
+        timeout.tv_sec = 0;
+        timeout.tv_usec = 100 * 1000;
+        read_fd_set = active_fd_set;
+
+        if (select(FD_SETSIZE, &read_fd_set, NULL, NULL, &timeout) < 0) {
+            int err = errno;
+            error("%s: select error %s(%d)\n", __func__, strerror(err), err);
+            break;
+        }
+
+        for (i = 0; i < FD_SETSIZE; ++i) {
+            if (FD_ISSET(i, &read_fd_set)) {
+                if (i == sock) {
+                    int new_sock = accept(i, NULL, NULL);
+                    if (new_sock > 0) {
+#ifdef BEOREMOTE_ONE_PLUGIN_VERBOSE
+                        DBG("Accepting new socket %d, %d", sock, new_sock);
+#endif
+                        fcntl(new_sock, F_SETFL, O_NONBLOCK);
+                        FD_SET(new_sock, &active_fd_set);
+                        beoremote_one_socket = new_sock;
+#ifdef BUILDTYPE_PC
+                        g_atomic_int_set(&beoremote_one_thread_accepted_connection, TRUE);
+#endif
+                    }
+                } else if (beoremote_one_socket_read(i) < 0) {
+#ifdef BEOREMOTE_ONE_PLUGIN_VERBOSE
+                    DBG("Closing socket: %d", i);
+#endif
+                    close(i);
+                    FD_CLR(i, &active_fd_set);
+#ifdef BUILDTYPE_PC
+                    g_atomic_int_set(&beoremote_one_thread_accepted_connection, FALSE);
+#endif
+                }
+            }
+        }
+    }
+
+    return NULL;
+}
+
+static uint8_t beoremote_one_attrib_read(struct attribute *attrib, struct btd_device *device, gpointer user_data)
+{
+    struct btd_adapter *adapter = (struct btd_adapter *)user_data;
+    int attrib_type;
+    size_t attrib_size;
+#ifdef BEOREMOTE_ONE_PLUGIN_VERBOSE
+    char device_address_str[BA_ADDRESS_STRING_BUFFER_SIZE] = { 0 };
+    char print_content_buffer[ATTRIB_DATA_AS_STRING_BUFFER_SIZE];
+#endif
+
+    if (!attrib) {
+        return 0;
+    }
+
+    for (attrib_type = 0; attrib_type < BEOREMOTE_ONE_ATTRIB_MAX; attrib_type++) {
+        if (attrib->handle == beoremote_one_data[attrib_type].handle) {
+            aqquire_lock();
+            attrib_size = beoremote_one_attrib_size((enum beoremote_one_attrib)attrib_type);
+            /* For strings only send the length of the string and not the real size */
+            if (attrib_size == BEOREMOTE_ONE_ATTRIB_MAX_SIZE) {
+                attrib_size = strlen((char *)beoremote_one_data[attrib_type].value);
+            }
+#ifdef BEOREMOTE_ONE_PLUGIN_VERBOSE
+            device_address_or_local_to_str(device, &device_address_str[0]);
+            DBG("Read attribute from device %s (0x%04x)%s:[%s]",
+                device_address_str,
+                attrib->handle,
+                beoremote_one_attrib_to_string((enum beoremote_one_attrib)attrib_type),
+                beoremote_one_attrib_data_to_string(
+                    (enum beoremote_one_attrib)attrib_type,
+                    beoremote_one_data[attrib_type].value,
+                    attrib_size,
+                    &print_content_buffer,
+                    sizeof(print_content_buffer)));
+#endif
+            attrib_db_update(adapter, attrib->handle, NULL, beoremote_one_data[attrib_type].value, attrib_size, NULL);
+            release_lock();
+            break;
+        }
+    }
+
+    update_connected_device_address(device);
+
+    return 0;
+}
+
+static uint8_t beoremote_one_attrib_write(struct attribute *attrib, struct btd_device *device, gpointer user_data)
+{
+    (void)device;
+    (void)user_data;
+
+    int attrib_type, attrib_size;
+    uint8_t data[BEOREMOTE_ONE_ATTRIB_MAX_SIZE + BEOREMOTE_ONE_SOCKET_MSG_HEADER_SIZE];
+    size_t max_len;
+
+#ifdef BEOREMOTE_ONE_PLUGIN_TRACE
+    DBG("-> %p", g_thread_self());
+#endif
+
+    if (!attrib) {
+        return 0;
+    }
+
+    for (attrib_type = 0; attrib_type < BEOREMOTE_ONE_ATTRIB_MAX; attrib_type++) {
+        if (attrib->handle == beoremote_one_data[attrib_type].handle) {
+#ifdef BEOREMOTE_ONE_PLUGIN_VERBOSE
+            DBG("Write for attribute (0x%04x)%s with length %d", attrib->handle, beoremote_one_attrib_to_string((enum beoremote_one_attrib)attrib_type), (int)attrib->len);
+#endif
+            attrib_size = attrib->len;
+            max_len = beoremote_one_attrib_size((enum beoremote_one_attrib)attrib_type);
+            if ((size_t)attrib_size > max_len)
+                attrib_size = max_len;
+
+            aqquire_lock();
+            memcpy(beoremote_one_data[attrib_type].value, attrib->data, attrib_size);
+            if (attrib_size == BEOREMOTE_ONE_ATTRIB_MAX_SIZE) {
+                beoremote_one_data[attrib_type].value[attrib_size - 1] = '\0';
+            }
+            release_lock();
+
+            data[0] = attrib_type;
+            data[1] = (htons(attrib_size) >> 0) & 0xFF;
+            data[2] = (htons(attrib_size) >> 8) & 0xFF;
+
+            memcpy(&data[BEOREMOTE_ONE_SOCKET_MSG_HEADER_SIZE], attrib->data, attrib_size);
+            beoremote_one_socket_write(data, attrib_size + BEOREMOTE_ONE_SOCKET_MSG_HEADER_SIZE);
+
+#ifdef BEOREMOTE_ONE_PLUGIN_VERBOSE
+            DBG("Sent new value for attribute (0x%04x)%s with length %d", attrib->handle, beoremote_one_attrib_to_string((enum beoremote_one_attrib)attrib_type), attrib_size);
+#endif
+            break;
+        }
+    }
+
+#ifdef BEOREMOTE_ONE_PLUGIN_TRACE
+    DBG("<- %p", g_thread_self());
+#endif
+    return 0;
+}
+
+static void beoremote_one_init(void)
+{
+    g_mutex_init(&beoremote_one_mutex);
+#ifdef BUILDTYPE_PC
+    g_cond_init(&beoremote_one_attrib_updated_condition);
+    g_atomic_int_set(&socket_created_test, FALSE);
+#endif
+    beoremote_one_thread = g_thread_new(NULL, beoremote_one_socket_thread, NULL);
+#ifdef BUILDTYPE_PC
+    while (g_atomic_int_get(&socket_created_test) != TRUE) {
+        boost::this_thread::sleep(boost::posix_time::milliseconds(25));
+    }
+#endif
+}
+
+static void beoremote_one_exit(void)
+{
+    g_atomic_int_set(&beoremote_one_thread_stop, TRUE);
+    g_thread_join(beoremote_one_thread);
+    beoremote_one_thread = NULL;
+#ifdef BUILDTYPE_PC
+    g_cond_clear(&beoremote_one_attrib_updated_condition);
+#endif
+    g_mutex_clear(&beoremote_one_mutex);
+}
+
+#endif
diff -Naur a/plugins/beoremote_one_types.c b/plugins/beoremote_one_types.c
--- a/plugins/beoremote_one_types.c	1970-01-01 00:00:00.000000000 +0000
+++ b/plugins/beoremote_one_types.c	2019-03-12 08:47:19.916261659 +0000
@@ -0,0 +1,184 @@
+#include "beoremote_one_types.h"
+
+#include <stdio.h>
+
+#define NEWLINE_REPLACE_CHAR ','
+
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wswitch-enum"
+
+size_t beoremote_one_attrib_size(enum beoremote_one_attrib attrib)
+{
+    size_t attrib_size;
+
+    switch (attrib) {
+    case BEOREMOTE_ONE_ATTRIB_DISC_TRACK:
+    case BEOREMOTE_ONE_ATTRIB_ACTIVE_STAND_POSITION:
+    case BEOREMOTE_ONE_ATTRIB_ACTIVE_SPEAKER_GROUP:
+    case BEOREMOTE_ONE_ATTRIB_ACTIVE_SOUND_MODE:
+    case BEOREMOTE_ONE_ATTRIB_ACTIVE_PICTURE_FORMAT:
+    case BEOREMOTE_ONE_ATTRIB_ACTIVE_PICTURE_MODE:
+    case BEOREMOTE_ONE_ATTRIB_ACTIVE_2D_3D_MODE:
+    case BEOREMOTE_ONE_ATTRIB_ACTIVE_SOURCE:
+    case BEOREMOTE_ONE_ATTRIB_ACTIVE_CUSTOM_COMMAND:
+    case BEOREMOTE_ONE_ATTRIB_ACTIVE_HOME_CONTROL_SCENE:
+    case BEOREMOTE_ONE_ATTRIB_CINEMA_MODE:
+    case BEOREMOTE_ONE_ATTRIB_ACTIVE_EXPERIENCE:
+    case BEOREMOTE_ONE_ATTRIB_CONTROL_1:
+    case BEOREMOTE_ONE_ATTRIB_CONTROL_2:
+    case BEOREMOTE_ONE_ATTRIB_ACTIVE_SOURCE_CONTENT:
+        attrib_size = 1;
+        break;
+
+    case BEOREMOTE_ONE_ATTRIB_FEATURES:
+    case BEOREMOTE_ONE_ATTRIB_FEATURES_CHANGED:
+        attrib_size = 16;
+        break;
+
+    default:
+        attrib_size = BEOREMOTE_ONE_ATTRIB_MAX_SIZE;
+        break;
+    }
+
+    return attrib_size;
+}
+
+#pragma GCC diagnostic pop
+
+const char *beoremote_one_attrib_to_string(enum beoremote_one_attrib attrib)
+{
+    switch (attrib) {
+    case BEOREMOTE_ONE_ATTRIB_VERSION:
+        return "BEOREMOTE_ONE_ATTRIB_VERSION";
+    case BEOREMOTE_ONE_ATTRIB_FEATURES:
+        return "BEOREMOTE_ONE_ATTRIB_FEATURES";
+    case BEOREMOTE_ONE_ATTRIB_FEATURES_CHANGED:
+        return "BEOREMOTE_ONE_ATTRIB_FEATURES_CHANGED";
+    case BEOREMOTE_ONE_ATTRIB_INJECT_PRESS:
+        return "BEOREMOTE_ONE_ATTRIB_INJECT_PRESS";
+    case BEOREMOTE_ONE_ATTRIB_INJECT_RELEASE:
+        return "BEOREMOTE_ONE_ATTRIB_INJECT_RELEASE";
+    case BEOREMOTE_ONE_ATTRIB_DISC_TRACK:
+        return "BEOREMOTE_ONE_ATTRIB_DISC_TRACK";
+    case BEOREMOTE_ONE_ATTRIB_STAND_POSITIONS:
+        return "BEOREMOTE_ONE_ATTRIB_STAND_POSITIONS";
+    case BEOREMOTE_ONE_ATTRIB_ACTIVE_STAND_POSITION:
+        return "BEOREMOTE_ONE_ATTRIB_ACTIVE_STAND_POSITION";
+    case BEOREMOTE_ONE_ATTRIB_SPEAKER_GROUPS:
+        return "BEOREMOTE_ONE_ATTRIB_SPEAKER_GROUPS";
+    case BEOREMOTE_ONE_ATTRIB_ACTIVE_SPEAKER_GROUP:
+        return "BEOREMOTE_ONE_ATTRIB_ACTIVE_SPEAKER_GROUP";
+    case BEOREMOTE_ONE_ATTRIB_SOUND_MODES:
+        return "BEOREMOTE_ONE_ATTRIB_SOUND_MODES";
+    case BEOREMOTE_ONE_ATTRIB_ACTIVE_SOUND_MODE:
+        return "BEOREMOTE_ONE_ATTRIB_ACTIVE_SOUND_MODE";
+    case BEOREMOTE_ONE_ATTRIB_PICTURE_FORMATS:
+        return "BEOREMOTE_ONE_ATTRIB_PICTURE_FORMATS";
+    case BEOREMOTE_ONE_ATTRIB_ACTIVE_PICTURE_FORMAT:
+        return "BEOREMOTE_ONE_ATTRIB_ACTIVE_PICTURE_FORMAT";
+    case BEOREMOTE_ONE_ATTRIB_PICTURE_MODES:
+        return "BEOREMOTE_ONE_ATTRIB_PICTURE_MODES";
+    case BEOREMOTE_ONE_ATTRIB_ACTIVE_PICTURE_MODE:
+        return "BEOREMOTE_ONE_ATTRIB_ACTIVE_PICTURE_MODE";
+    case BEOREMOTE_ONE_ATTRIB_PICTURE_MUTE:
+        return "BEOREMOTE_ONE_ATTRIB_PICTURE_MUTE";
+    case BEOREMOTE_ONE_ATTRIB_2D_3D_MODES:
+        return "BEOREMOTE_ONE_ATTRIB_2D_3D_MODES";
+    case BEOREMOTE_ONE_ATTRIB_ACTIVE_2D_3D_MODE:
+        return "BEOREMOTE_ONE_ATTRIB_ACTIVE_2D_3D_MODE";
+    case BEOREMOTE_ONE_ATTRIB_TV_SOURCES:
+        return "BEOREMOTE_ONE_ATTRIB_TV_SOURCES";
+    case BEOREMOTE_ONE_ATTRIB_MUSIC_SOURCES:
+        return "BEOREMOTE_ONE_ATTRIB_MUSIC_SOURCES";
+    case BEOREMOTE_ONE_ATTRIB_ACTIVE_SOURCE:
+        return "BEOREMOTE_ONE_ATTRIB_ACTIVE_SOURCE";
+    case BEOREMOTE_ONE_ATTRIB_CUSTOM_COMMANDS:
+        return "BEOREMOTE_ONE_ATTRIB_CUSTOM_COMMANDS";
+    case BEOREMOTE_ONE_ATTRIB_ACTIVE_CUSTOM_COMMAND:
+        return "BEOREMOTE_ONE_ATTRIB_ACTIVE_CUSTOM_COMMAND";
+    case BEOREMOTE_ONE_ATTRIB_HOME_CONTROL_SCENES:
+        return "BEOREMOTE_ONE_ATTRIB_HOME_CONTROL_SCENES";
+    case BEOREMOTE_ONE_ATTRIB_ACTIVE_HOME_CONTROL_SCENE:
+        return "BEOREMOTE_ONE_ATTRIB_ACTIVE_HOME_CONTROL_SCENE";
+    case BEOREMOTE_ONE_ATTRIB_CINEMA_MODE:
+        return "BEOREMOTE_ONE_ATTRIB_CINEMA_MODE";
+    case BEOREMOTE_ONE_ATTRIB_EXPERIENCES:
+        return "BEOREMOTE_ONE_ATTRIB_EXPERIENCES";
+    case BEOREMOTE_ONE_ATTRIB_ACTIVE_EXPERIENCE:
+        return "BEOREMOTE_ONE_ATTRIB_ACTIVE_EXPERIENCE";
+    case BEOREMOTE_ONE_ATTRIB_CONTROL_1:
+        return "BEOREMOTE_ONE_ATTRIB_CONTROL_1";
+    case BEOREMOTE_ONE_ATTRIB_CONTROL_2:
+        return "BEOREMOTE_ONE_ATTRIB_CONTROL_2";
+    case BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_1:
+        return "BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_1";
+    case BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_2:
+        return "BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_2";
+    case BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_3:
+        return "BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_3";
+    case BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_4:
+        return "BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_4";
+    case BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_5:
+        return "BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_5";
+    case BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_6:
+        return "BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_6";
+    case BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_7:
+        return "BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_7";
+    case BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_8:
+        return "BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_8";
+    case BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_9:
+        return "BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_9";
+    case BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_10:
+        return "BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_10";
+    case BEOREMOTE_ONE_ATTRIB_ACTIVE_SOURCE_CONTENT:
+        return "BEOREMOTE_ONE_ATTRIB_ACTIVE_SOURCE_CONTENT";
+    case BEOREMOTE_ONE_ATTRIB_MY_BUTTONS:
+        return "BEOREMOTE_ONE_ATTRIB_MY_BUTTONS";
+    case BEOREMOTE_ONE_ATTRIB_MAX:
+        return "BEOREMOTE_ONE_ATTRIB_MAX";
+    }
+    return "beoremote_one_attrib enum has not been mapped!";
+}
+
+char *beoremote_one_attrib_data_to_string(enum beoremote_one_attrib attrib, const uint8_t *data, size_t data_size, char *buffer, size_t buffer_size)
+{
+    char *src = (char *)data;
+    const char *src_end = src + data_size;
+    char *dest = buffer;
+    const char *dest_end = dest + buffer_size;
+    static const size_t PRINT_BUFFER_SIZE = 6; // Size of ',0xNN' incl. zero-terminator
+
+    if (beoremote_one_attrib_size(attrib) == BEOREMOTE_ONE_ATTRIB_MAX_SIZE) {
+        // Copy every char in data, replace each newline with NEWLINE_REPLACE_CHAR
+        while (dest < dest_end && src < src_end && *src != '\0') {
+            if (*src == '\n')
+                *dest = NEWLINE_REPLACE_CHAR;
+            else
+                *dest = *src;
+            ++src;
+            ++dest;
+        }
+        if (dest < dest_end)
+            *dest = '\0';
+        else if (dest > buffer) // Replace last char in buffer with zero-terminator
+            *--dest = '\0';
+    } else {
+        if ((data_size == 0 || buffer_size < PRINT_BUFFER_SIZE - 1) && buffer_size > 0)
+            *buffer = '\0';
+        else {
+            // Print first byte without leading comma
+            if (buffer_size >= PRINT_BUFFER_SIZE - 1 && src < src_end)
+                sprintf(dest, "0x%02x", *src);
+            src += 1;
+            dest += PRINT_BUFFER_SIZE - 2;
+            // Print next bytes with leading comma
+            while (src < src_end && dest + PRINT_BUFFER_SIZE <= dest_end) {
+                sprintf(dest, ",0x%02x", *src);
+                src += 1;
+                dest += PRINT_BUFFER_SIZE - 1;
+            }
+        }
+    }
+
+    return buffer;
+}
diff -Naur a/plugins/beoremote_one_types.h b/plugins/beoremote_one_types.h
--- a/plugins/beoremote_one_types.h	1970-01-01 00:00:00.000000000 +0000
+++ b/plugins/beoremote_one_types.h	2019-03-12 06:12:39.032458052 +0000
@@ -0,0 +1,75 @@
+#ifndef BEOREMOTE_ONE_TYPES_H_
+#define BEOREMOTE_ONE_TYPES_H_
+
+#include <stddef.h>
+#include <stdint.h>
+
+#define BEOREMOTE_ONE_CONNECTED_MAX 8
+#define BEOREMOTE_ONE_ATTRIB_MAX_SIZE 512
+#define BEOREMOTE_ONE_SOCKET_MSG_HEADER_SIZE 3
+#define BEOREMOTE_ONE_SOCKET_PATH "/var/run/beoremote_one_socket"
+
+enum beoremote_one_attrib {
+    BEOREMOTE_ONE_ATTRIB_VERSION = 1,
+    BEOREMOTE_ONE_ATTRIB_FEATURES,
+    BEOREMOTE_ONE_ATTRIB_FEATURES_CHANGED,
+    BEOREMOTE_ONE_ATTRIB_INJECT_PRESS,
+    BEOREMOTE_ONE_ATTRIB_INJECT_RELEASE,
+    BEOREMOTE_ONE_ATTRIB_DISC_TRACK,
+    BEOREMOTE_ONE_ATTRIB_STAND_POSITIONS,
+    BEOREMOTE_ONE_ATTRIB_ACTIVE_STAND_POSITION,
+    BEOREMOTE_ONE_ATTRIB_SPEAKER_GROUPS,
+    BEOREMOTE_ONE_ATTRIB_ACTIVE_SPEAKER_GROUP,
+    BEOREMOTE_ONE_ATTRIB_SOUND_MODES,
+    BEOREMOTE_ONE_ATTRIB_ACTIVE_SOUND_MODE,
+    BEOREMOTE_ONE_ATTRIB_PICTURE_FORMATS,
+    BEOREMOTE_ONE_ATTRIB_ACTIVE_PICTURE_FORMAT,
+    BEOREMOTE_ONE_ATTRIB_PICTURE_MODES,
+    BEOREMOTE_ONE_ATTRIB_ACTIVE_PICTURE_MODE,
+    BEOREMOTE_ONE_ATTRIB_PICTURE_MUTE,
+    BEOREMOTE_ONE_ATTRIB_2D_3D_MODES,
+    BEOREMOTE_ONE_ATTRIB_ACTIVE_2D_3D_MODE,
+    BEOREMOTE_ONE_ATTRIB_TV_SOURCES,
+    BEOREMOTE_ONE_ATTRIB_MUSIC_SOURCES,
+    BEOREMOTE_ONE_ATTRIB_ACTIVE_SOURCE,
+    BEOREMOTE_ONE_ATTRIB_CUSTOM_COMMANDS,
+    BEOREMOTE_ONE_ATTRIB_ACTIVE_CUSTOM_COMMAND,
+    BEOREMOTE_ONE_ATTRIB_HOME_CONTROL_SCENES,
+    BEOREMOTE_ONE_ATTRIB_ACTIVE_HOME_CONTROL_SCENE,
+    BEOREMOTE_ONE_ATTRIB_CINEMA_MODE,
+    BEOREMOTE_ONE_ATTRIB_EXPERIENCES,
+    BEOREMOTE_ONE_ATTRIB_ACTIVE_EXPERIENCE,
+    BEOREMOTE_ONE_ATTRIB_CONTROL_1,
+    BEOREMOTE_ONE_ATTRIB_CONTROL_2,
+    BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_1,
+    BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_2,
+    BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_3,
+    BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_4,
+    BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_5,
+    BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_6,
+    BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_7,
+    BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_8,
+    BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_9,
+    BEOREMOTE_ONE_ATTRIB_SOURCE_CONTENT_10,
+    BEOREMOTE_ONE_ATTRIB_ACTIVE_SOURCE_CONTENT,
+    BEOREMOTE_ONE_ATTRIB_MY_BUTTONS,
+
+    /* Must be the last item! */
+    BEOREMOTE_ONE_ATTRIB_MAX
+};
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+size_t beoremote_one_attrib_size(enum beoremote_one_attrib attrib);
+
+const char *beoremote_one_attrib_to_string(enum beoremote_one_attrib attrib);
+
+char *beoremote_one_attrib_data_to_string(enum beoremote_one_attrib, const uint8_t *, size_t, char *, size_t);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* BEOREMOTE_ONE_TYPES_H_ */
