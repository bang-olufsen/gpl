From 42dfc991a21183d61fdea419b24aea4748fb2a6c Mon Sep 17 00:00:00 2001
From: Simon Mikuda <simon.mikuda@streamunlimited.com>
Date: Mon, 24 Apr 2017 15:09:06 +0200
Subject: [PATCH] deviceinfo: Add serial number to device property

- Read it from deviceinfo profile
- Store it to configuration
- Add it to dbus

Signed-off-by: Simon Mikuda <simon.mikuda@streamunlimited.com>
---
 client/main.c                    |  1 +
 lib/uuid.h                       |  1 +
 profiles/deviceinfo/deviceinfo.c | 35 +++++++++++++++++++++++++++-
 src/device.c                     | 50 ++++++++++++++++++++++++++++++++++++++++
 src/device.h                     |  1 +
 5 files changed, 87 insertions(+), 1 deletion(-)

diff --git a/client/main.c b/client/main.c
index 255cbd5..2ef7d9e 100644
--- a/client/main.c
+++ b/client/main.c
@@ -1368,6 +1368,7 @@ static void cmd_info(const char *arg)
 	print_property(proxy, "LegacyPairing");
 	print_uuids(proxy);
 	print_property(proxy, "Modalias");
+	print_property(proxy, "Serial");
 	print_property(proxy, "ManufacturerData");
 	print_property(proxy, "ServiceData");
 	print_property(proxy, "RSSI");
diff --git a/lib/uuid.h b/lib/uuid.h
index 2dcfe9e..0fb1526 100644
--- a/lib/uuid.h
+++ b/lib/uuid.h
@@ -53,6 +53,7 @@ extern "C" {
 #define BNEP_SVC_UUID		"0000000f-0000-1000-8000-00805f9b34fb"
 
 #define PNPID_UUID		"00002a50-0000-1000-8000-00805f9b34fb"
+#define SERIAL_NUMBER_UUID		"00002a25-0000-1000-8000-00805f9b34fb"
 #define DEVICE_INFORMATION_UUID	"0000180a-0000-1000-8000-00805f9b34fb"
 
 #define GATT_UUID		"00001801-0000-1000-8000-00805f9b34fb"
diff --git a/profiles/deviceinfo/deviceinfo.c b/profiles/deviceinfo/deviceinfo.c
index fa94efe..4d72e20 100644
--- a/profiles/deviceinfo/deviceinfo.c
+++ b/profiles/deviceinfo/deviceinfo.c
@@ -78,14 +78,45 @@ static void handle_pnpid(struct btd_device *device, uint16_t value_handle)
 		DBG("Failed to send request to read pnpid");
 }
 
+static void read_serial_number_cb(bool success, uint8_t att_ecode, const uint8_t *value,
+					uint16_t length, void *user_data)
+{
+	struct btd_device *device = user_data;
+
+	if (!success) {
+		error("Error reading serial number value: %s",
+						att_ecode2str(att_ecode));
+		return;
+	}
+
+	if (length <= 0) {
+		error("Error reading serial number: Empty value");
+		return;
+	}
+
+	char *serial_number = g_strndup(value, length);
+	btd_device_set_serial_number(device, serial_number);
+	g_free(serial_number);
+}
+
+static void handle_serial_number(struct btd_device *device, uint16_t value_handle)
+{
+	struct bt_gatt_client *client = btd_device_get_gatt_client(device);
+
+	if (!bt_gatt_client_read_value(client, value_handle,
+						read_serial_number_cb, device, NULL))
+		DBG("Failed to send request to read serial number");
+}
+
 static void handle_characteristic(struct gatt_db_attribute *attr,
 								void *user_data)
 {
 	struct btd_device *device = user_data;
 	uint16_t value_handle;
-	bt_uuid_t uuid, pnpid_uuid;
+	bt_uuid_t uuid, pnpid_uuid, serial_number_uuid;
 
 	bt_string_to_uuid(&pnpid_uuid, PNPID_UUID);
+	bt_string_to_uuid(&serial_number_uuid, SERIAL_NUMBER_UUID);
 
 	if (!gatt_db_attribute_get_char_data(attr, NULL, &value_handle, NULL,
 								NULL, &uuid)) {
@@ -95,6 +126,8 @@ static void handle_characteristic(struct gatt_db_attribute *attr,
 
 	if (bt_uuid_cmp(&pnpid_uuid, &uuid) == 0)
 		handle_pnpid(device, value_handle);
+	else if (bt_uuid_cmp(&serial_number_uuid, &uuid) == 0)
+		handle_serial_number(device, value_handle);
 	else {
 		char uuid_str[MAX_LEN_UUID_STR];
 
diff --git a/src/device.c b/src/device.c
index d12b2d7..25a4576 100644
--- a/src/device.c
+++ b/src/device.c
@@ -197,6 +197,7 @@ struct btd_device {
 	uint16_t	version;
 	uint16_t	appearance;
 	char		*modalias;
+	char        *serial_number;
 	struct btd_adapter	*adapter;
 	GSList		*uuids;
 	GSList		*primaries;		/* List of primary services */
@@ -437,6 +438,12 @@ static gboolean store_device_info_cb(gpointer user_data)
 		g_key_file_remove_group(key_file, "DeviceID", NULL);
 	}
 
+	if (device->serial_number)
+		g_key_file_set_string(key_file, "DeviceID", "Serial",
+					device->serial_number);
+	else
+		g_key_file_remove_key(key_file, "DeviceID", "Serial", NULL);
+
 	if (device->local_csrk)
 		store_csrk(device->local_csrk, key_file, "LocalSignatureKey");
 
@@ -446,6 +453,7 @@ static gboolean store_device_info_cb(gpointer user_data)
 	create_file(filename, S_IRUSR | S_IWUSR);
 
 	str = g_key_file_to_data(key_file, &length, NULL);
+
 	g_file_set_contents(filename, str, length, NULL);
 	g_free(str);
 
@@ -655,6 +663,7 @@ static void device_free(gpointer user_data)
 	g_free(device->path);
 	g_free(device->alias);
 	free(device->modalias);
+	g_free(device->serial_number);
 	g_free(device);
 }
 
@@ -1141,6 +1150,28 @@ static gboolean dev_property_exists_modalias(const GDBusPropertyTable *property,
 	return device->modalias ? TRUE : FALSE;
 }
 
+static gboolean dev_property_get_serial(const GDBusPropertyTable *property,
+					DBusMessageIter *iter, void *data)
+{
+	struct btd_device *device = data;
+
+	if (!device->serial_number)
+		return FALSE;
+
+	dbus_message_iter_append_basic(iter, DBUS_TYPE_STRING,
+							&device->serial_number);
+
+	return TRUE;
+}
+
+static gboolean dev_property_exists_serial(const GDBusPropertyTable *property,
+								void *data)
+{
+	struct btd_device *device = data;
+
+	return device->serial_number ? TRUE : FALSE;
+}
+
 static gboolean dev_property_get_adapter(const GDBusPropertyTable *property,
 					DBusMessageIter *iter, void *data)
 {
@@ -2589,6 +2620,8 @@ static const GDBusPropertyTable device_properties[] = {
 	{ "UUIDs", "as", dev_property_get_uuids },
 	{ "Modalias", "s", dev_property_get_modalias, NULL,
 						dev_property_exists_modalias },
+	{ "Serial", "s", dev_property_get_serial, NULL,
+						dev_property_exists_serial },
 	{ "Adapter", "o", dev_property_get_adapter },
 	{ "ManufacturerData", "a{qv}", dev_property_get_manufacturer_data,
 				NULL, dev_property_manufacturer_data_exist },
@@ -2955,6 +2988,9 @@ next:
 							"Version", NULL);
 
 		btd_device_set_pnpid(device, source, vendor, product, version);
+
+		device->serial_number = g_key_file_get_string(key_file, "DeviceID",
+							"Serial", NULL);
 	}
 
 	if (store_needed)
@@ -6117,6 +6153,20 @@ void btd_device_set_pnpid(struct btd_device *device, uint16_t source,
 	store_device_info(device);
 }
 
+void btd_device_set_serial_number(struct btd_device *device, const char *serial_number)
+{
+	if (g_strcmp0(device->serial_number, serial_number) == 0)
+		return;
+
+	g_free(device->serial_number);
+	device->serial_number = g_strdup(serial_number);
+
+	g_dbus_emit_property_changed(dbus_conn, device->path,
+						DEVICE_INTERFACE, "Serial");
+
+	store_device_info(device);
+}
+
 static void service_state_changed(struct btd_service *service,
 						btd_service_state_t old_state,
 						btd_service_state_t new_state,
diff --git a/src/device.h b/src/device.h
index 3cab366..ca90442 100644
--- a/src/device.h
+++ b/src/device.h
@@ -143,6 +143,7 @@ int device_unblock(struct btd_device *device, gboolean silent,
 							gboolean update_only);
 void btd_device_set_pnpid(struct btd_device *device, uint16_t source,
 			uint16_t vendor, uint16_t product, uint16_t version);
+void btd_device_set_serial_number(struct btd_device *device, const char *serial_number);
 
 int device_connect_le(struct btd_device *dev);
 
-- 
2.7.4

