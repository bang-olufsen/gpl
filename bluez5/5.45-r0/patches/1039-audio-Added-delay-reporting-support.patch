From 35cc96758310ddce39bde0b5a193fbdd8ce8f4ad Mon Sep 17 00:00:00 2001
From: Simon Mikuda <simon.mikuda@streamunlimited.com>
Date: Mon, 4 Feb 2019 10:23:05 +0100
Subject: [PATCH] audio: Added delay reporting support

Delay can be added per endpoint via setting "Delay" property when
"SetConfiguration" is called or can be added dynamically via calling
"SetSinkDelay" to Media object.

Signed-off-by: Stanislav Ruzani <stanislav.ruzani@streamunlimited.com>
Signed-off-by: Simon Mikuda <simon.mikuda@streamunlimited.com>
---
 android/a2dp.c         |  2 +-
 android/avdtp.c        |  3 +++
 android/avdtp.h        |  1 +
 android/avdtptest.c    |  2 +-
 doc/media-api.txt      |  4 ++++
 profiles/audio/a2dp.c  | 10 +++++++--
 profiles/audio/a2dp.h  |  4 +++-
 profiles/audio/avdtp.c | 18 +++++++++++++++-
 profiles/audio/avdtp.h |  3 +++
 profiles/audio/media.c | 58 ++++++++++++++++++++++++++++++++++++++++++--------
 unit/test-avdtp.c      | 22 +++++++++----------
 11 files changed, 101 insertions(+), 26 deletions(-)

diff --git a/android/a2dp.c b/android/a2dp.c
index f219042..e466028 100644
--- a/android/a2dp.c
+++ b/android/a2dp.c
@@ -1335,7 +1335,7 @@ static uint8_t register_endpoint(const uint8_t *uuid, uint8_t codec,
 	endpoint->codec = codec;
 	endpoint->sep = avdtp_register_sep(lseps, AVDTP_SEP_TYPE_SOURCE,
 						AVDTP_MEDIA_TYPE_AUDIO,
-						codec, FALSE, &sep_ind,
+						codec, FALSE, 0, &sep_ind,
 						&sep_cfm, endpoint);
 	endpoint->caps = presets->data;
 	endpoint->presets = g_slist_copy(g_slist_nth(presets, 1));
diff --git a/android/avdtp.c b/android/avdtp.c
index bab305b..0932fe9 100644
--- a/android/avdtp.c
+++ b/android/avdtp.c
@@ -323,6 +323,7 @@ struct avdtp_local_sep {
 	uint32_t vndcodec_vendor;
 	uint16_t vndcodec_codec;
 	gboolean delay_reporting;
+	uint32_t delay;
 	GSList *caps;
 	struct avdtp_sep_ind *ind;
 	struct avdtp_sep_cfm *cfm;
@@ -3373,6 +3374,7 @@ struct avdtp_local_sep *avdtp_register_sep(struct queue *lseps, uint8_t type,
 						uint8_t media_type,
 						uint8_t codec_type,
 						gboolean delay_reporting,
+						uint32_t delay,
 						struct avdtp_sep_ind *ind,
 						struct avdtp_sep_cfm *cfm,
 						void *user_data)
@@ -3394,6 +3396,7 @@ struct avdtp_local_sep *avdtp_register_sep(struct queue *lseps, uint8_t type,
 	sep->cfm = cfm;
 	sep->user_data = user_data;
 	sep->delay_reporting = delay_reporting;
+	sep->delay = delay;
 
 	DBG("SEP %p registered: type:%d codec:%d seid:%d", sep,
 			sep->info.type, sep->codec, sep->info.seid);
diff --git a/android/avdtp.h b/android/avdtp.h
index 07516a8..307288e 100644
--- a/android/avdtp.h
+++ b/android/avdtp.h
@@ -270,6 +270,7 @@ struct avdtp_local_sep *avdtp_register_sep(struct queue *lseps, uint8_t type,
 						uint8_t media_type,
 						uint8_t codec_type,
 						gboolean delay_reporting,
+						uint32_t delay,
 						struct avdtp_sep_ind *ind,
 						struct avdtp_sep_cfm *cfm,
 						void *user_data);
diff --git a/android/avdtptest.c b/android/avdtptest.c
index ce34443..aad9f4b 100644
--- a/android/avdtptest.c
+++ b/android/avdtptest.c
@@ -871,7 +871,7 @@ int main(int argc, char *argv[])
 	lseps = queue_new();
 
 	local_sep = avdtp_register_sep(lseps, dev_role, AVDTP_MEDIA_TYPE_AUDIO,
-					0x00, TRUE, &sep_ind, &sep_cfm, NULL);
+					0x00, TRUE, 0, &sep_ind, &sep_cfm, NULL);
 	if (!local_sep) {
 		printf("Failed to register sep\n");
 		exit(1);
diff --git a/doc/media-api.txt b/doc/media-api.txt
index 10dfd1c..6c3d711 100644
--- a/doc/media-api.txt
+++ b/doc/media-api.txt
@@ -45,6 +45,10 @@ Methods		void RegisterEndpoint(object endpoint, dict properties)
 
 			Unregister sender end point.
 
+		void SetSinkDelay(uint32 delay)
+
+			Set audio sink delay for all endpoints in 1/10 of miliseconds.
+
 		void RegisterPlayer(object player, dict properties)
 
 			Register a media player object to sender, the sender
diff --git a/profiles/audio/a2dp.c b/profiles/audio/a2dp.c
index 0eb37a9..284c8fd 100644
--- a/profiles/audio/a2dp.c
+++ b/profiles/audio/a2dp.c
@@ -1643,7 +1643,7 @@ static void a2dp_server_unregister(struct a2dp_server *server)
 }
 
 struct a2dp_sep *a2dp_add_sep(struct btd_adapter *adapter, uint8_t type,
-				uint8_t codec, gboolean delay_reporting,
+				uint8_t codec, gboolean delay_reporting, uint32_t delay,
 				struct a2dp_endpoint *endpoint,
 				void *user_data, GDestroyNotify destroy,
 				int *err)
@@ -1677,7 +1677,7 @@ struct a2dp_sep *a2dp_add_sep(struct btd_adapter *adapter, uint8_t type,
 
 	sep->lsep = avdtp_register_sep(server->seps, type,
 					AVDTP_MEDIA_TYPE_AUDIO, codec,
-					delay_reporting, &endpoint_ind,
+					delay_reporting, delay, &endpoint_ind,
 					&cfm, sep);
 
 	if (sep->lsep == NULL) {
@@ -2275,6 +2275,11 @@ gboolean a2dp_sep_unlock(struct a2dp_sep *sep, struct avdtp *session)
 	return TRUE;
 }
 
+void a2dp_sep_set_delay(struct a2dp_sep *sep, unsigned int delay)
+{
+	avdtp_sep_set_delay(sep->lsep, delay);
+}
+
 struct avdtp_stream *a2dp_sep_get_stream(struct a2dp_sep *sep)
 {
 	return sep->stream;
@@ -2542,5 +2547,6 @@ static void a2dp_exit(void)
 	btd_profile_unregister(&a2dp_sink_profile);
 }
 
+
 BLUETOOTH_PLUGIN_DEFINE(a2dp, VERSION, BLUETOOTH_PLUGIN_PRIORITY_DEFAULT,
 							a2dp_init, a2dp_exit)
diff --git a/profiles/audio/a2dp.h b/profiles/audio/a2dp.h
index 2c388bb..0eadcd5 100644
--- a/profiles/audio/a2dp.h
+++ b/profiles/audio/a2dp.h
@@ -64,7 +64,7 @@ typedef void (*a2dp_stream_cb_t) (struct avdtp *session, int err,
 					void *user_data);
 
 struct a2dp_sep *a2dp_add_sep(struct btd_adapter *adapter, uint8_t type,
-				uint8_t codec, gboolean delay_reporting,
+				uint8_t codec, gboolean delay_reporting, uint32_t delay,
 				struct a2dp_endpoint *endpoint,
 				void *user_data, GDestroyNotify destroy,
 				int *err);
@@ -88,6 +88,8 @@ gboolean a2dp_cancel(unsigned int id);
 
 gboolean a2dp_sep_lock(struct a2dp_sep *sep, struct avdtp *session);
 gboolean a2dp_sep_unlock(struct a2dp_sep *sep, struct avdtp *session);
+void a2dp_sep_set_delay(struct a2dp_sep *sep, unsigned int delay);
+unsigned int a2dp_sep_get_delay(struct a2dp_sep *sep);
 struct avdtp_stream *a2dp_sep_get_stream(struct a2dp_sep *sep);
 struct btd_device *a2dp_setup_get_device(struct a2dp_setup *setup);
 struct avdtp *a2dp_avdtp_get(struct btd_device *device);
diff --git a/profiles/audio/avdtp.c b/profiles/audio/avdtp.c
index 2d09873..12dbed9 100644
--- a/profiles/audio/avdtp.c
+++ b/profiles/audio/avdtp.c
@@ -331,6 +331,7 @@ struct avdtp_local_sep {
 	struct seid_info info;
 	uint8_t codec;
 	gboolean delay_reporting;
+	uint32_t delay;
 	GSList *caps;
 	struct avdtp_sep_ind *ind;
 	struct avdtp_sep_cfm *cfm;
@@ -981,7 +982,7 @@ static void avdtp_sep_set_state(struct avdtp *session,
 	switch (state) {
 	case AVDTP_STATE_CONFIGURED:
 		if (sep->info.type == AVDTP_SEP_TYPE_SINK)
-			avdtp_delay_report(session, stream, stream->delay);
+			avdtp_delay_report(session, stream, sep->delay);
 		break;
 	case AVDTP_STATE_OPEN:
 		stream->starting = FALSE;
@@ -1446,6 +1447,7 @@ static void setconf_cb(struct avdtp *session, struct avdtp_stream *stream,
 
 	sep = stream->lsep;
 	sep->stream = stream;
+
 	sep->info.inuse = 1;
 	session->streams = g_slist_append(session->streams, stream);
 
@@ -3594,6 +3596,7 @@ struct avdtp_local_sep *avdtp_register_sep(struct queue *lseps, uint8_t type,
 						uint8_t media_type,
 						uint8_t codec_type,
 						gboolean delay_reporting,
+						uint32_t delay,
 						struct avdtp_sep_ind *ind,
 						struct avdtp_sep_cfm *cfm,
 						void *user_data)
@@ -3615,6 +3618,7 @@ struct avdtp_local_sep *avdtp_register_sep(struct queue *lseps, uint8_t type,
 	sep->cfm = cfm;
 	sep->user_data = user_data;
 	sep->delay_reporting = delay_reporting;
+	sep->delay = delay;
 
 	DBG("SEP %p registered: type:%d codec:%d seid:%d", sep,
 			sep->info.type, sep->codec, sep->info.seid);
@@ -3703,6 +3707,18 @@ gboolean avdtp_is_seps_inuse(struct avdtp *session)
 	return inuse;
 }
 
+void avdtp_sep_set_delay(struct avdtp_local_sep *sep, unsigned int delay)
+{
+	if (sep->delay != delay) {
+		sep->delay = delay;
+
+		if (sep->stream && sep->stream->session) {
+			uint16_t delay = sep->delay;
+			avdtp_delay_report(sep->stream->session, sep->stream, delay);
+		}
+	}
+}
+
 struct btd_adapter *avdtp_get_adapter(struct avdtp *session)
 {
 	return device_get_adapter(session->device);
diff --git a/profiles/audio/avdtp.h b/profiles/audio/avdtp.h
index f7643f9..2aff994 100644
--- a/profiles/audio/avdtp.h
+++ b/profiles/audio/avdtp.h
@@ -278,6 +278,7 @@ struct avdtp_local_sep *avdtp_register_sep(struct queue *lseps, uint8_t type,
 						uint8_t media_type,
 						uint8_t codec_type,
 						gboolean delay_reporting,
+						uint32_t delay,
 						struct avdtp_sep_ind *ind,
 						struct avdtp_sep_cfm *cfm,
 						void *user_data);
@@ -293,6 +294,8 @@ int avdtp_unregister_sep(struct queue *lseps, struct avdtp_local_sep *sep);
 avdtp_state_t avdtp_sep_get_state(struct avdtp_local_sep *sep);
 gboolean avdtp_is_seps_inuse(struct avdtp *session);
 
+void avdtp_sep_set_delay(struct avdtp_local_sep *sep, unsigned int delay);
+
 void avdtp_error_init(struct avdtp_error *err, uint8_t type, int id);
 const char *avdtp_strerror(struct avdtp_error *err);
 uint8_t avdtp_error_category(struct avdtp_error *err);
diff --git a/profiles/audio/media.c b/profiles/audio/media.c
index e232266..2366930 100644
--- a/profiles/audio/media.c
+++ b/profiles/audio/media.c
@@ -66,6 +66,7 @@ struct media_adapter {
 	GSList			*endpoints;	/* Endpoints list */
 	GSList			*players;	/* Players list */
 	bool			single_connection;
+	unsigned int delay; /* default audio delay */
 };
 
 struct endpoint_request {
@@ -83,6 +84,7 @@ struct media_endpoint {
 	char			*path;		/* Endpoint object path */
 	char			*uuid;		/* Endpoint property UUID */
 	uint8_t			codec;		/* Endpoint codec */
+	uint32_t		delay;		/* Endpoint delay */
 	uint8_t			*capabilities;	/* Endpoint property capabilities */
 	size_t			size;		/* Endpoint capabilities size */
 	guint			hs_watch;
@@ -600,7 +602,7 @@ static gboolean endpoint_init_a2dp_source(struct media_endpoint *endpoint,
 {
 	endpoint->sep = a2dp_add_sep(endpoint->adapter->btd_adapter,
 					AVDTP_SEP_TYPE_SOURCE, endpoint->codec,
-					delay_reporting, &a2dp_endpoint,
+					delay_reporting, 0, &a2dp_endpoint,
 					endpoint, a2dp_destroy_endpoint, err);
 	if (endpoint->sep == NULL)
 		return FALSE;
@@ -609,12 +611,12 @@ static gboolean endpoint_init_a2dp_source(struct media_endpoint *endpoint,
 }
 
 static gboolean endpoint_init_a2dp_sink(struct media_endpoint *endpoint,
-						gboolean delay_reporting,
+						gboolean delay_reporting, uint32_t delay,
 						int *err)
 {
 	endpoint->sep = a2dp_add_sep(endpoint->adapter->btd_adapter,
 					AVDTP_SEP_TYPE_SINK, endpoint->codec,
-					delay_reporting, &a2dp_endpoint,
+					delay_reporting, delay, &a2dp_endpoint,
 					endpoint, a2dp_destroy_endpoint, err);
 	if (endpoint->sep == NULL)
 		return FALSE;
@@ -723,6 +725,7 @@ static struct media_endpoint *media_endpoint_create(struct media_adapter *adapte
 						const char *path,
 						const char *uuid,
 						gboolean delay_reporting,
+						uint32_t delay,
 						uint8_t codec,
 						uint8_t *capabilities,
 						int size,
@@ -736,6 +739,7 @@ static struct media_endpoint *media_endpoint_create(struct media_adapter *adapte
 	endpoint->path = g_strdup(path);
 	endpoint->uuid = g_strdup(uuid);
 	endpoint->codec = codec;
+	endpoint->delay = delay;
 
 	if (size > 0) {
 		endpoint->capabilities = g_new(uint8_t, size);
@@ -750,7 +754,7 @@ static struct media_endpoint *media_endpoint_create(struct media_adapter *adapte
 							delay_reporting, err);
 	else if (strcasecmp(uuid, A2DP_SINK_UUID) == 0)
 		succeeded = endpoint_init_a2dp_sink(endpoint,
-							delay_reporting, err);
+							delay_reporting, endpoint->delay ? endpoint->delay : adapter->delay, err);
 	else if (strcasecmp(uuid, HFP_AG_UUID) == 0 ||
 					strcasecmp(uuid, HSP_AG_UUID) == 0)
 		succeeded = TRUE;
@@ -789,7 +793,7 @@ static struct media_endpoint *media_endpoint_create(struct media_adapter *adapte
 }
 
 static int parse_properties(DBusMessageIter *props, const char **uuid,
-				gboolean *delay_reporting, uint8_t *codec,
+				gboolean *delay_reporting, uint32_t *delay, uint8_t *codec,
 				uint8_t **capabilities, int *size)
 {
 	gboolean has_uuid = FALSE;
@@ -821,6 +825,10 @@ static int parse_properties(DBusMessageIter *props, const char **uuid,
 			if (var != DBUS_TYPE_BOOLEAN)
 				return -EINVAL;
 			dbus_message_iter_get_basic(&value, delay_reporting);
+		} else if (strcasecmp(key, "Delay") == 0) {
+			if (var != DBUS_TYPE_UINT32)
+				return -EINVAL;
+			dbus_message_iter_get_basic(&value, delay);
 		} else if (strcasecmp(key, "Capabilities") == 0) {
 			DBusMessageIter array;
 
@@ -845,8 +853,9 @@ static DBusMessage *register_endpoint(DBusConnection *conn, DBusMessage *msg,
 	DBusMessageIter args, props;
 	const char *sender, *path, *uuid;
 	gboolean delay_reporting = FALSE;
-	uint8_t codec;
-	uint8_t *capabilities;
+	uint8_t codec = 0;
+	uint32_t delay = 0;
+	uint8_t *capabilities = 0;
 	int size = 0;
 	int err;
 
@@ -864,11 +873,11 @@ static DBusMessage *register_endpoint(DBusConnection *conn, DBusMessage *msg,
 	if (dbus_message_iter_get_arg_type(&props) != DBUS_TYPE_DICT_ENTRY)
 		return btd_error_invalid_args(msg);
 
-	if (parse_properties(&props, &uuid, &delay_reporting, &codec,
+	if (parse_properties(&props, &uuid, &delay_reporting, &delay, &codec,
 						&capabilities, &size) < 0)
 		return btd_error_invalid_args(msg);
 
-	if (media_endpoint_create(adapter, sender, path, uuid, delay_reporting,
+	if (media_endpoint_create(adapter, sender, path, uuid, delay_reporting, delay,
 				codec, capabilities, size, &err) == NULL) {
 		if (err == -EPROTONOSUPPORT)
 			return btd_error_not_supported(msg);
@@ -902,6 +911,35 @@ static DBusMessage *unregister_endpoint(DBusConnection *conn, DBusMessage *msg,
 	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
 }
 
+static DBusMessage *set_sink_delay(DBusConnection *conn, DBusMessage *msg,
+					void *data)
+{
+	struct media_adapter *adapter = data;
+	GSList *l;
+	uint32_t delay;
+
+	if (!dbus_message_get_args(msg, NULL,
+				DBUS_TYPE_UINT32, &delay,
+				DBUS_TYPE_INVALID))
+		return btd_error_invalid_args(msg);
+
+	adapter->delay = delay;
+
+	for (l = adapter->endpoints; l; l = l->next) {
+		struct media_endpoint *endpoint = l->data;
+
+		if (endpoint->sep == NULL)
+			continue;
+
+		if (endpoint->delay)
+			continue;
+
+		a2dp_sep_set_delay(endpoint->sep, delay);
+	}
+
+	return g_dbus_create_reply(msg, DBUS_TYPE_INVALID);
+}
+
 static struct media_player *media_adapter_find_player(
 						struct media_adapter *adapter,
 						const char *sender,
@@ -1892,6 +1930,8 @@ static const GDBusMethodTable media_methods[] = {
 		NULL, register_endpoint) },
 	{ GDBUS_METHOD("UnregisterEndpoint",
 		GDBUS_ARGS({ "endpoint", "o" }), NULL, unregister_endpoint) },
+	{ GDBUS_METHOD("SetSinkDelay",
+		GDBUS_ARGS({ "delay", "u" }), NULL, set_sink_delay) },
 	{ GDBUS_METHOD("RegisterPlayer",
 		GDBUS_ARGS({ "player", "o" }, { "properties", "a{sv}" }),
 		NULL, register_player) },
diff --git a/unit/test-avdtp.c b/unit/test-avdtp.c
index dd8aed7..89f8d20 100644
--- a/unit/test-avdtp.c
+++ b/unit/test-avdtp.c
@@ -519,7 +519,7 @@ static void test_server(gconstpointer data)
 
 	sep = avdtp_register_sep(context->lseps, AVDTP_SEP_TYPE_SOURCE,
 					AVDTP_MEDIA_TYPE_AUDIO,
-					0x00, FALSE, &sep_ind, &sep_cfm,
+					0x00, FALSE, 0, &sep_ind, &sep_cfm,
 					context);
 	g_assert(sep);
 
@@ -533,7 +533,7 @@ static void test_server_1_3(gconstpointer data)
 
 	sep = avdtp_register_sep(context->lseps, AVDTP_SEP_TYPE_SOURCE,
 					AVDTP_MEDIA_TYPE_AUDIO,
-					0x00, TRUE, &sep_ind, NULL, context);
+					0x00, TRUE, 0, &sep_ind, NULL, context);
 	g_assert(sep);
 
 	g_idle_add(send_pdu, context);
@@ -546,7 +546,7 @@ static void test_server_1_3_sink(gconstpointer data)
 
 	sep = avdtp_register_sep(context->lseps, AVDTP_SEP_TYPE_SINK,
 					AVDTP_MEDIA_TYPE_AUDIO,
-					0x00, TRUE, &sep_ind, NULL, context);
+					0x00, TRUE, 0, &sep_ind, NULL, context);
 	g_assert(sep);
 
 	g_idle_add(send_pdu, context);
@@ -568,7 +568,7 @@ static void test_server_seid(gconstpointer data)
 	for (i = 0; i < sizeof(int) * 8; i++) {
 		sep = avdtp_register_sep(context->lseps, AVDTP_SEP_TYPE_SINK,
 						AVDTP_MEDIA_TYPE_AUDIO,
-						0x00, TRUE, &sep_ind, NULL,
+						0x00, TRUE, 0, &sep_ind, NULL,
 						context);
 		g_assert(sep);
 	}
@@ -576,7 +576,7 @@ static void test_server_seid(gconstpointer data)
 	/* Now add (MAX_SEID + 1) SEP -> it shall fail */
 	sep = avdtp_register_sep(context->lseps, AVDTP_SEP_TYPE_SINK,
 						AVDTP_MEDIA_TYPE_AUDIO,
-						0x00, TRUE, &sep_ind, NULL,
+						0x00, TRUE, 0, &sep_ind, NULL,
 						context);
 	g_assert(!sep);
 
@@ -592,7 +592,7 @@ static void test_server_seid_duplicate(gconstpointer data)
 	for (i = 0; i < 2; i++) {
 		sep = avdtp_register_sep(context->lseps, AVDTP_SEP_TYPE_SINK,
 						AVDTP_MEDIA_TYPE_AUDIO,
-						0x00, TRUE, &sep_ind, NULL,
+						0x00, TRUE, 0, &sep_ind, NULL,
 						context);
 		g_assert(sep);
 	}
@@ -606,7 +606,7 @@ static void test_server_seid_duplicate(gconstpointer data)
 	/* Now register new element */
 	sep = avdtp_register_sep(context->lseps, AVDTP_SEP_TYPE_SINK,
 						AVDTP_MEDIA_TYPE_AUDIO,
-						0x00, TRUE, &sep_ind, NULL,
+						0x00, TRUE, 0, &sep_ind, NULL,
 						context);
 	g_assert(sep);
 
@@ -662,7 +662,7 @@ static void test_server_frg(gconstpointer data)
 
 	sep = avdtp_register_sep(context->lseps, AVDTP_SEP_TYPE_SOURCE,
 						AVDTP_MEDIA_TYPE_AUDIO,
-						0x00, TRUE, &sep_ind_frg,
+						0x00, TRUE, 0, &sep_ind_frg,
 						NULL, context);
 	g_assert(sep);
 
@@ -743,7 +743,7 @@ static void test_client(gconstpointer data)
 
 	sep = avdtp_register_sep(context->lseps, AVDTP_SEP_TYPE_SINK,
 					AVDTP_MEDIA_TYPE_AUDIO,
-					0x00, FALSE, NULL, &sep_cfm, context);
+					0x00, FALSE, 0, NULL, &sep_cfm, context);
 
 	context->sep = sep;
 
@@ -757,7 +757,7 @@ static void test_client_1_3(gconstpointer data)
 
 	sep = avdtp_register_sep(context->lseps, AVDTP_SEP_TYPE_SINK,
 					AVDTP_MEDIA_TYPE_AUDIO,
-					0x00, TRUE, NULL, &sep_cfm, context);
+					0x00, TRUE, 0, NULL, &sep_cfm, context);
 
 	context->sep = sep;
 
@@ -771,7 +771,7 @@ static void test_client_frg(gconstpointer data)
 
 	sep = avdtp_register_sep(context->lseps, AVDTP_SEP_TYPE_SINK,
 					AVDTP_MEDIA_TYPE_AUDIO,
-					0x00, TRUE, NULL, &sep_cfm, context);
+					0x00, TRUE, 0, NULL, &sep_cfm, context);
 
 	context->sep = sep;
 
-- 
2.7.4

